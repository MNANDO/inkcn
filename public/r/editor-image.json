{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "editor-image",
  "title": "Image Extension",
  "description": "An extension for the Inkcn editor to use image blocks",
  "registryDependencies": [
    "https://inkcn.vercel.app/r/editor.json",
    "dialog"
  ],
  "files": [
    {
      "path": "components/editor/nodes/image-node.tsx",
      "content": "import {\n\t$applyNodeReplacement,\n\tDecoratorNode,\n\tDOMExportOutput,\n\tEditorConfig,\n\tLexicalNode,\n\tNodeKey,\n\tSerializedLexicalNode,\n\tSpread,\n\t$getNodeByKey,\n\t$getSelection,\n\t$isNodeSelection,\n\t$setSelection,\n\tCLICK_COMMAND,\n\tCOMMAND_PRIORITY_LOW,\n\tcreateCommand,\n\tDRAGSTART_COMMAND,\n\tKEY_ESCAPE_COMMAND,\n\tSELECTION_CHANGE_COMMAND,\n\tLexicalCommand,\n} from 'lexical';\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable';\nimport { useLexicalNodeSelection } from '@lexical/react/useLexicalNodeSelection';\nimport { mergeRegister } from '@lexical/utils';\nimport {\n\tJSX,\n\tSuspense,\n\tuseCallback,\n\tuseEffect,\n\tuseMemo,\n\tuseRef,\n\tuseState,\n} from 'react';\n\nexport const RIGHT_CLICK_IMAGE_COMMAND: LexicalCommand<MouseEvent> =\n\tcreateCommand('RIGHT_CLICK_IMAGE_COMMAND');\n\ntype ImageStatus =\n\t| { error: true }\n\t| { error: false; width: number; height: number };\n\nconst imageCache = new Map<string, Promise<ImageStatus> | ImageStatus>();\n\nfunction useSuspenseImage(src: string): ImageStatus {\n\tlet cached = imageCache.get(src);\n\tif (cached && 'error' in cached && typeof cached.error === 'boolean') {\n\t\treturn cached;\n\t}\n\tif (!cached) {\n\t\tcached = new Promise<ImageStatus>((resolve) => {\n\t\t\tconst img = new Image();\n\t\t\timg.src = src;\n\t\t\timg.onload = () =>\n\t\t\t\tresolve({\n\t\t\t\t\terror: false,\n\t\t\t\t\theight: img.naturalHeight,\n\t\t\t\t\twidth: img.naturalWidth,\n\t\t\t\t});\n\t\t\timg.onerror = () => resolve({ error: true });\n\t\t}).then((result) => {\n\t\t\timageCache.set(src, result);\n\t\t\treturn result;\n\t\t});\n\t\timageCache.set(src, cached);\n\t\tthrow cached;\n\t}\n\tthrow cached;\n}\n\nfunction BrokenImage(): JSX.Element {\n\treturn (\n\t\t// eslint-disable-next-line @next/next/no-img-element\n\t\t<img\n\t\t\tsrc=\"/images/image-broken.svg\"\n\t\t\tstyle={{ height: 200, opacity: 0.2, width: 200 }}\n\t\t\tdraggable=\"false\"\n\t\t\talt=\"Broken image\"\n\t\t/>\n\t);\n}\n\nfunction LazyImage({\n\taltText,\n\tclassName,\n\timageRef,\n\tsrc,\n\twidth,\n\theight,\n\tmaxWidth,\n\tonError,\n}: {\n\taltText: string;\n\tclassName: string | null;\n\theight: 'inherit' | number;\n\timageRef: React.RefObject<HTMLImageElement | null>;\n\tmaxWidth: number;\n\tsrc: string;\n\twidth: 'inherit' | number;\n\tonError: () => void;\n}): JSX.Element {\n\tconst status = useSuspenseImage(src);\n\n\tuseEffect(() => {\n\t\tif (status.error) {\n\t\t\tonError();\n\t\t}\n\t}, [status.error, onError]);\n\n\tif (status.error) {\n\t\treturn <BrokenImage />;\n\t}\n\n\treturn (\n\t\t// eslint-disable-next-line @next/next/no-img-element\n\t\t<img\n\t\t\tclassName={className || undefined}\n\t\t\tsrc={src}\n\t\t\talt={altText}\n\t\t\tref={imageRef}\n\t\t\tstyle={{\n\t\t\t\theight,\n\t\t\t\tmaxWidth,\n\t\t\t\twidth,\n\t\t\t}}\n\t\t\tonError={onError}\n\t\t\tdraggable=\"false\"\n\t\t/>\n\t);\n}\n\n// --- Image Resizer ---\n\nfunction ImageResizer({\n\timageRef,\n\tmaxWidth,\n\tonResizeStart,\n\tonResizeEnd,\n}: {\n\timageRef: React.RefObject<HTMLImageElement | null>;\n\tmaxWidth: number;\n\tonResizeStart: () => void;\n\tonResizeEnd: (\n\t\twidth: 'inherit' | number,\n\t\theight: 'inherit' | number,\n\t) => void;\n}) {\n\tconst controlWrapperRef = useRef<HTMLDivElement>(null);\n\tconst startXRef = useRef(0);\n\tconst startYRef = useRef(0);\n\tconst startWidthRef = useRef(0);\n\tconst startHeightRef = useRef(0);\n\tconst ratioRef = useRef(1);\n\tconst directionRef = useRef<'ne' | 'nw' | 'se' | 'sw'>('se');\n\n\tconst handlePointerDown = (\n\t\tevent: React.PointerEvent,\n\t\tdirection: 'ne' | 'nw' | 'se' | 'sw',\n\t) => {\n\t\tconst image = imageRef.current;\n\t\tif (!image) return;\n\n\t\tevent.preventDefault();\n\t\tdirectionRef.current = direction;\n\t\tstartXRef.current = event.clientX;\n\t\tstartYRef.current = event.clientY;\n\n\t\tconst { width, height } = image.getBoundingClientRect();\n\t\tstartWidthRef.current = width;\n\t\tstartHeightRef.current = height;\n\t\tratioRef.current = width / height;\n\n\t\tonResizeStart();\n\n\t\tconst onPointerMove = (e: PointerEvent) => {\n\t\t\tconst dir = directionRef.current;\n\t\t\tconst diffX = e.clientX - startXRef.current;\n\t\t\tconst diffY = e.clientY - startYRef.current;\n\n\t\t\tlet newWidth = startWidthRef.current;\n\t\t\tlet newHeight = startHeightRef.current;\n\n\t\t\tif (dir.includes('e')) newWidth += diffX;\n\t\t\tif (dir.includes('w')) newWidth -= diffX;\n\t\t\tif (dir.includes('s')) newHeight += diffY;\n\t\t\tif (dir.includes('n')) newHeight -= diffY;\n\n\t\t\t// Maintain aspect ratio for corner handles\n\t\t\tif (dir.length === 2) {\n\t\t\t\tconst widthRatio = newWidth / startWidthRef.current;\n\t\t\t\tconst heightRatio = newHeight / startHeightRef.current;\n\t\t\t\tconst ratio = Math.max(widthRatio, heightRatio);\n\t\t\t\tnewWidth = startWidthRef.current * ratio;\n\t\t\t\tnewHeight = startHeightRef.current * ratio;\n\t\t\t}\n\n\t\t\t// Clamp\n\t\t\tnewWidth = Math.max(100, Math.min(newWidth, maxWidth));\n\t\t\tnewHeight = Math.max(100, newHeight);\n\n\t\t\timage.style.width = `${newWidth}px`;\n\t\t\timage.style.height = `${newHeight}px`;\n\t\t};\n\n\t\tconst onPointerUp = () => {\n\t\t\tdocument.removeEventListener('pointermove', onPointerMove);\n\t\t\tdocument.removeEventListener('pointerup', onPointerUp);\n\n\t\t\tconst finalWidth = imageRef.current?.width || startWidthRef.current;\n\t\t\tconst finalHeight =\n\t\t\t\timageRef.current?.height || startHeightRef.current;\n\t\t\tonResizeEnd(finalWidth, finalHeight);\n\t\t};\n\n\t\tdocument.addEventListener('pointermove', onPointerMove);\n\t\tdocument.addEventListener('pointerup', onPointerUp);\n\t};\n\n\tconst handleStyle =\n\t\t'absolute bg-primary border border-background rounded-sm w-2 h-2 z-10';\n\n\treturn (\n\t\t<div ref={controlWrapperRef} className=\"absolute inset-0\">\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -top-1 -left-1 cursor-nw-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'nw')}\n\t\t\t/>\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -top-1 -right-1 cursor-ne-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'ne')}\n\t\t\t/>\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -bottom-1 -left-1 cursor-sw-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'sw')}\n\t\t\t/>\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -bottom-1 -right-1 cursor-se-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'se')}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n\nexport default function ImageNodeDecorator({\n\tsrc,\n\taltText,\n\tnodeKey,\n\twidth,\n\theight,\n\tmaxWidth,\n\tresizable,\n}: {\n\taltText: string;\n\theight: 'inherit' | number;\n\tmaxWidth: number;\n\tnodeKey: NodeKey;\n\tresizable: boolean;\n\tsrc: string;\n\twidth: 'inherit' | number;\n}): JSX.Element {\n\tconst imageRef = useRef<HTMLImageElement | null>(null);\n\tconst [isSelected, setSelected, clearSelection] =\n\t\tuseLexicalNodeSelection(nodeKey);\n\tconst [isResizing, setIsResizing] = useState(false);\n\tconst [editor] = useLexicalComposerContext();\n\tconst activeEditorRef = useRef<\n\t\tReturnType<typeof useLexicalComposerContext>[0] | null\n\t>(null);\n\tconst [isLoadError, setIsLoadError] = useState(false);\n\tconst isEditable = useLexicalEditable();\n\n\tconst isInNodeSelection = useMemo(\n\t\t() =>\n\t\t\tisSelected &&\n\t\t\teditor.getEditorState().read(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\treturn $isNodeSelection(selection) && selection.has(nodeKey);\n\t\t\t}),\n\t\t[editor, isSelected, nodeKey],\n\t);\n\n\tconst $onEscape = useCallback(() => {\n\t\tif (isSelected && isInNodeSelection) {\n\t\t\t$setSelection(null);\n\t\t\teditor.update(() => {\n\t\t\t\tsetSelected(false);\n\t\t\t\tconst parentRootElement = editor.getRootElement();\n\t\t\t\tif (parentRootElement !== null) {\n\t\t\t\t\tparentRootElement.focus();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}, [editor, isSelected, isInNodeSelection, setSelected]);\n\n\tconst onClick = useCallback(\n\t\t(payload: MouseEvent) => {\n\t\t\tif (isResizing) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (payload.target === imageRef.current) {\n\t\t\t\tif (payload.shiftKey) {\n\t\t\t\t\tsetSelected(!isSelected);\n\t\t\t\t} else {\n\t\t\t\t\tclearSelection();\n\t\t\t\t\tsetSelected(true);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t[isResizing, isSelected, setSelected, clearSelection],\n\t);\n\n\tconst onRightClick = useCallback(\n\t\t(event: MouseEvent): void => {\n\t\t\teditor.getEditorState().read(() => {\n\t\t\t\tconst latestSelection = $getSelection();\n\t\t\t\tconst domElement = event.target as HTMLElement;\n\t\t\t\tif (\n\t\t\t\t\tdomElement.tagName === 'IMG' &&\n\t\t\t\t\t$isNodeSelection(latestSelection) &&\n\t\t\t\t\tlatestSelection.getNodes().length === 1\n\t\t\t\t) {\n\t\t\t\t\teditor.dispatchCommand(RIGHT_CLICK_IMAGE_COMMAND, event);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[editor],\n\t);\n\n\tuseEffect(() => {\n\t\treturn mergeRegister(\n\t\t\teditor.registerCommand(\n\t\t\t\tSELECTION_CHANGE_COMMAND,\n\t\t\t\t(_, activeEditor) => {\n\t\t\t\t\tactiveEditorRef.current = activeEditor;\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerCommand(\n\t\t\t\tDRAGSTART_COMMAND,\n\t\t\t\t(event) => {\n\t\t\t\t\tif (event.target === imageRef.current) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t);\n\t}, [editor]);\n\n\tuseEffect(() => {\n\t\tlet rootCleanup = () => {};\n\t\treturn mergeRegister(\n\t\t\teditor.registerCommand<MouseEvent>(\n\t\t\t\tCLICK_COMMAND,\n\t\t\t\tonClick,\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerCommand<MouseEvent>(\n\t\t\t\tRIGHT_CLICK_IMAGE_COMMAND,\n\t\t\t\tonClick,\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerCommand(\n\t\t\t\tKEY_ESCAPE_COMMAND,\n\t\t\t\t$onEscape,\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerRootListener((rootElement) => {\n\t\t\t\trootCleanup();\n\t\t\t\trootCleanup = () => {};\n\t\t\t\tif (rootElement) {\n\t\t\t\t\trootElement.addEventListener('contextmenu', onRightClick);\n\t\t\t\t\trootCleanup = () =>\n\t\t\t\t\t\trootElement.removeEventListener(\n\t\t\t\t\t\t\t'contextmenu',\n\t\t\t\t\t\t\tonRightClick,\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t() => rootCleanup(),\n\t\t);\n\t}, [editor, $onEscape, onClick, onRightClick]);\n\n\tconst onResizeEnd = (\n\t\tnextWidth: 'inherit' | number,\n\t\tnextHeight: 'inherit' | number,\n\t) => {\n\t\tsetTimeout(() => {\n\t\t\tsetIsResizing(false);\n\t\t}, 200);\n\n\t\teditor.update(() => {\n\t\t\tconst node = $getNodeByKey(nodeKey);\n\t\t\tif ($isImageNode(node)) {\n\t\t\t\tnode.setWidthAndHeight(nextWidth, nextHeight);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst onResizeStart = () => {\n\t\tsetIsResizing(true);\n\t};\n\n\tconst draggable = isInNodeSelection && !isResizing;\n\tconst isFocused = (isSelected || isResizing) && isEditable;\n\n\treturn (\n\t\t<Suspense fallback={null}>\n\t\t\t<div draggable={draggable} className=\"relative inline-block\">\n\t\t\t\t{isLoadError ? (\n\t\t\t\t\t<BrokenImage />\n\t\t\t\t) : (\n\t\t\t\t\t<LazyImage\n\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\tisFocused\n\t\t\t\t\t\t\t\t? `focused ${isInNodeSelection ? 'draggable' : ''}`\n\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrc={src}\n\t\t\t\t\t\taltText={altText}\n\t\t\t\t\t\timageRef={imageRef}\n\t\t\t\t\t\twidth={width}\n\t\t\t\t\t\theight={height}\n\t\t\t\t\t\tmaxWidth={maxWidth}\n\t\t\t\t\t\tonError={() => setIsLoadError(true)}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{resizable && isInNodeSelection && isFocused && (\n\t\t\t\t\t<ImageResizer\n\t\t\t\t\t\timageRef={imageRef}\n\t\t\t\t\t\tmaxWidth={maxWidth}\n\t\t\t\t\t\tonResizeStart={onResizeStart}\n\t\t\t\t\t\tonResizeEnd={onResizeEnd}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</Suspense>\n\t);\n}\n\nexport interface ImagePayload {\n\taltText: string;\n\theight?: number;\n\tkey?: NodeKey;\n\tmaxWidth?: number;\n\tsrc: string;\n\twidth?: number;\n}\n\nexport type SerializedImageNode = Spread<\n\t{\n\t\tsrc: string;\n\t\taltText: string;\n\t\tmaxWidth: number;\n\t\twidth?: number;\n\t\theight?: number;\n\t},\n\tSerializedLexicalNode\n>;\n\nexport class ImageNode extends DecoratorNode<JSX.Element> {\n\t__src: string;\n\t__altText: string;\n\t__maxWidth: number;\n\t__width: 'inherit' | number;\n\t__height: 'inherit' | number;\n\n\tconstructor(\n\t\tsrc: string,\n\t\taltText: string,\n\t\tmaxWidth: number,\n\t\twidth?: 'inherit' | number,\n\t\theight?: 'inherit' | number,\n\t\tkey?: NodeKey,\n\t) {\n\t\tsuper(key);\n\n\t\tthis.__src = src;\n\t\tthis.__altText = altText;\n\t\tthis.__maxWidth = maxWidth;\n\t\tthis.__width = width || 'inherit';\n\t\tthis.__height = height || 'inherit';\n\t}\n\n\tgetSrc(): string {\n\t\treturn this.__src;\n\t}\n\n\tgetAltText(): string {\n\t\treturn this.__altText;\n\t}\n\n\tsetWidthAndHeight(\n\t\twidth: 'inherit' | number,\n\t\theight: 'inherit' | number,\n\t): void {\n\t\tconst writable = this.getWritable();\n\t\twritable.__width = width;\n\t\twritable.__height = height;\n\t}\n\n\tstatic getType(): string {\n\t\treturn 'image';\n\t}\n\n\tstatic clone(node: ImageNode): ImageNode {\n\t\treturn new ImageNode(\n\t\t\tnode.__src,\n\t\t\tnode.__altText,\n\t\t\tnode.__maxWidth,\n\t\t\tnode.__width,\n\t\t\tnode.__height,\n\t\t\tnode.__key,\n\t\t);\n\t}\n\n\tstatic importJSON(serializedNode: SerializedImageNode): ImageNode {\n\t\treturn new ImageNode(\n\t\t\tserializedNode.src,\n\t\t\tserializedNode.altText,\n\t\t\tserializedNode.maxWidth,\n\t\t\tserializedNode.width,\n\t\t\tserializedNode.height,\n\t\t);\n\t}\n\texportJSON(): SerializedImageNode {\n\t\treturn {\n\t\t\t...super.exportJSON(),\n\t\t\taltText: this.getAltText(),\n\t\t\tmaxWidth: this.__maxWidth,\n\t\t\theight: this.__height === 'inherit' ? 0 : this.__height,\n\t\t\tsrc: this.getSrc(),\n\t\t\twidth: this.__width === 'inherit' ? 0 : this.__width,\n\t\t};\n\t}\n\n\tcreateDOM(config: EditorConfig): HTMLElement {\n\t\tconst span = document.createElement('span');\n\t\tconst theme = config.theme;\n\t\tconst className = theme.image;\n\t\tif (className !== undefined) {\n\t\t\tspan.className = className;\n\t\t}\n\t\treturn span;\n\t}\n\n\tupdateDOM(): false {\n\t\treturn false;\n\t}\n\n\tdecorate(): JSX.Element {\n\t\treturn (\n\t\t\t<Suspense fallback={null}>\n\t\t\t\t<ImageNodeDecorator\n\t\t\t\t\tsrc={this.__src}\n\t\t\t\t\taltText={this.__altText}\n\t\t\t\t\twidth={this.__width}\n\t\t\t\t\theight={this.__height}\n\t\t\t\t\tmaxWidth={this.__maxWidth}\n\t\t\t\t\tnodeKey={this.getKey()}\n\t\t\t\t\tresizable={true}\n\t\t\t\t/>\n\t\t\t</Suspense>\n\t\t);\n\t}\n\n\texportDOM(): DOMExportOutput {\n\t\tconst imgElement = document.createElement('img');\n\t\timgElement.setAttribute('src', this.__src);\n\t\timgElement.setAttribute('alt', this.__altText);\n\t\timgElement.setAttribute('width', this.__width.toString());\n\t\timgElement.setAttribute('height', this.__height.toString());\n\n\t\treturn { element: imgElement };\n\t}\n}\n\nexport function $createImageNode({\n\taltText,\n\theight,\n\tmaxWidth = 500,\n\tsrc,\n\twidth,\n\tkey,\n}: ImagePayload): ImageNode {\n\treturn $applyNodeReplacement(\n\t\tnew ImageNode(src, altText, maxWidth, width, height, key),\n\t);\n}\n\nexport function $isImageNode(\n\tnode: LexicalNode | null | undefined,\n): node is ImageNode {\n\treturn node instanceof ImageNode;\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/image-node.tsx"
    },
    {
      "path": "components/editor/extensions/image-extension.tsx",
      "content": "'use client';\n\nimport type { JSX } from 'react';\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $wrapNodeInElement, mergeRegister } from '@lexical/utils';\nimport {\n\t$createParagraphNode,\n\t$insertNodes,\n\t$isRootOrShadowRoot,\n\tCOMMAND_PRIORITY_EDITOR,\n\tconfigExtension,\n\tcreateCommand,\n\tdefineExtension,\n\tLexicalCommand,\n\tLexicalEditor,\n} from 'lexical';\nimport {\n\tChangeEvent,\n\tDragEvent as ReactDragEvent,\n\tFormEvent,\n\tuseCallback,\n\tuseEffect,\n\tuseRef,\n\tuseState,\n} from 'react';\n\nimport { $createImageNode, ImageNode, ImagePayload } from '../nodes/image-node';\nimport {\n\tDialog,\n\tDialogContent,\n\tDialogDescription,\n\tDialogFooter,\n\tDialogHeader,\n\tDialogTitle,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { ReactExtension } from '@lexical/react/ReactExtension';\n\nexport type InsertImagePayload = Readonly<ImagePayload>;\n\nexport const INSERT_IMAGE_COMMAND: LexicalCommand<InsertImagePayload> =\n\tcreateCommand('INSERT_IMAGE_COMMAND');\n\nexport const OPEN_INSERT_IMAGE_DIALOG_COMMAND: LexicalCommand<void> =\n\tcreateCommand('OPEN_INSERT_IMAGE_DIALOG');\n\ninterface ImageDecoratorProps {\n\tonUploadImage?: (file: File) => Promise<string>;\n}\n\nfunction ImageDecorator({\n\tonUploadImage,\n}: ImageDecoratorProps = {}): JSX.Element | null {\n\tconst [editor] = useLexicalComposerContext();\n\tconst [showDialog, setShowDialog] = useState(false);\n\n\tuseEffect(() => {\n\t\tif (!editor.hasNodes([ImageNode])) {\n\t\t\tthrow new Error(\n\t\t\t\t'ImageDecorator: ImageNode not registered on editor',\n\t\t\t);\n\t\t}\n\n\t\treturn mergeRegister(\n\t\t\teditor.registerCommand<InsertImagePayload>(\n\t\t\t\tINSERT_IMAGE_COMMAND,\n\t\t\t\t(payload) => {\n\t\t\t\t\tconst imageNode = $createImageNode(payload);\n\t\t\t\t\t$insertNodes([imageNode]);\n\t\t\t\t\tif ($isRootOrShadowRoot(imageNode.getParentOrThrow())) {\n\t\t\t\t\t\t$wrapNodeInElement(\n\t\t\t\t\t\t\timageNode,\n\t\t\t\t\t\t\t$createParagraphNode,\n\t\t\t\t\t\t).selectEnd();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_EDITOR,\n\t\t\t),\n\t\t\teditor.registerCommand(\n\t\t\t\tOPEN_INSERT_IMAGE_DIALOG_COMMAND,\n\t\t\t\t() => {\n\t\t\t\t\tsetShowDialog(true);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_EDITOR,\n\t\t\t),\n\t\t);\n\t}, [editor]);\n\n\treturn (\n\t\t<InsertImageDialog\n\t\t\teditor={editor}\n\t\t\topen={showDialog}\n\t\t\tonOpenChange={setShowDialog}\n\t\t\tonUploadImage={onUploadImage}\n\t\t/>\n\t);\n}\n\nfunction useFileDrop(onFile: (file: File) => void) {\n\tconst [isDragging, setIsDragging] = useState(false);\n\n\tfunction handleDrop(e: ReactDragEvent) {\n\t\te.preventDefault();\n\t\tsetIsDragging(false);\n\t\tconst f = e.dataTransfer.files[0];\n\t\tif (f?.type.startsWith('image/')) onFile(f);\n\t}\n\n\tfunction handleDragOver(e: ReactDragEvent) {\n\t\te.preventDefault();\n\t\tsetIsDragging(true);\n\t}\n\n\tfunction handleDragLeave(e: ReactDragEvent) {\n\t\te.preventDefault();\n\t\tsetIsDragging(false);\n\t}\n\n\tfunction resetDragging() {\n\t\tsetIsDragging(false);\n\t}\n\n\treturn {\n\t\tisDragging,\n\t\thandleDrop,\n\t\thandleDragOver,\n\t\thandleDragLeave,\n\t\tresetDragging,\n\t};\n}\n\ninterface InsertImageDialogProps {\n\teditor: LexicalEditor;\n\topen: boolean;\n\tonOpenChange: (open: boolean) => void;\n\tonUploadImage?: (file: File) => Promise<string>;\n}\n\nexport function InsertImageDialog({\n\teditor,\n\topen,\n\tonOpenChange,\n\tonUploadImage,\n}: InsertImageDialogProps) {\n\tconst [file, setFile] = useState<File | null>(null);\n\tconst [preview, setPreview] = useState<string | null>(null);\n\tconst [altText, setAltText] = useState('');\n\tconst [isUploading, setIsUploading] = useState(false);\n\tconst inputRef = useRef<HTMLInputElement>(null);\n\n\tfunction handleFile(f: File) {\n\t\tsetFile(f);\n\t\tsetPreview(URL.createObjectURL(f));\n\t}\n\n\tconst {\n\t\tisDragging,\n\t\thandleDrop,\n\t\thandleDragOver,\n\t\thandleDragLeave,\n\t\tresetDragging,\n\t} = useFileDrop(handleFile);\n\n\tconst reset = useCallback(() => {\n\t\tsetFile(null);\n\t\tsetPreview(null);\n\t\tsetAltText('');\n\t\tsetIsUploading(false);\n\t\tresetDragging();\n\t}, [resetDragging]);\n\n\tfunction handleOpenChange(next: boolean) {\n\t\tif (!next) reset();\n\t\tonOpenChange(next);\n\t}\n\n\tfunction handleFileChange(e: ChangeEvent<HTMLInputElement>) {\n\t\tconst f = e.target.files?.[0];\n\t\tif (f) handleFile(f);\n\t}\n\n\tasync function handleSubmit(e: FormEvent) {\n\t\te.preventDefault();\n\t\tif (!file || !onUploadImage) return;\n\n\t\tsetIsUploading(true);\n\t\ttry {\n\t\t\tconst src = await onUploadImage(file);\n\t\t\teditor.dispatchCommand(INSERT_IMAGE_COMMAND, {\n\t\t\t\tsrc,\n\t\t\t\taltText: altText.trim(),\n\t\t\t});\n\t\t\thandleOpenChange(false);\n\t\t} finally {\n\t\t\tsetIsUploading(false);\n\t\t}\n\t}\n\n\treturn (\n\t\t<Dialog open={open} onOpenChange={handleOpenChange}>\n\t\t\t<DialogContent>\n\t\t\t\t<DialogHeader>\n\t\t\t\t\t<DialogTitle>Upload Image</DialogTitle>\n\t\t\t\t\t<DialogDescription>\n\t\t\t\t\t\tDrag and drop an image or click to browse.\n\t\t\t\t\t</DialogDescription>\n\t\t\t\t</DialogHeader>\n\t\t\t\t<form onSubmit={handleSubmit} className=\"grid gap-4\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tref={inputRef}\n\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\taccept=\"image/*\"\n\t\t\t\t\t\tonChange={handleFileChange}\n\t\t\t\t\t\tclassName=\"hidden\"\n\t\t\t\t\t/>\n\t\t\t\t\t{preview ? (\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tonClick={() => inputRef.current?.click()}\n\t\t\t\t\t\t\tclassName=\"relative overflow-hidden rounded-md border\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\tsrc={preview}\n\t\t\t\t\t\t\t\talt=\"Preview\"\n\t\t\t\t\t\t\t\tclassName=\"max-h-48 w-full object-contain\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tonClick={() => inputRef.current?.click()}\n\t\t\t\t\t\t\tonDrop={handleDrop}\n\t\t\t\t\t\t\tonDragOver={handleDragOver}\n\t\t\t\t\t\t\tonDragLeave={handleDragLeave}\n\t\t\t\t\t\t\tclassName={`flex h-32 flex-col items-center justify-center gap-2 rounded-md border-2 border-dashed text-sm transition-colors ${\n\t\t\t\t\t\t\t\tisDragging\n\t\t\t\t\t\t\t\t\t? 'border-primary bg-primary/5'\n\t\t\t\t\t\t\t\t\t: 'border-muted-foreground/25 hover:border-muted-foreground/50'\n\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"text-muted-foreground\">\n\t\t\t\t\t\t\t\tDrop an image here, or click to browse\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</button>\n\t\t\t\t\t)}\n\t\t\t\t\t<Input\n\t\t\t\t\t\tplaceholder=\"Alt text (optional)\"\n\t\t\t\t\t\tvalue={altText}\n\t\t\t\t\t\tonChange={(e) => setAltText(e.target.value)}\n\t\t\t\t\t/>\n\t\t\t\t\t<DialogFooter>\n\t\t\t\t\t\t<Button type=\"submit\" disabled={!file || isUploading}>\n\t\t\t\t\t\t\t{isUploading ? 'Uploading...' : 'Upload'}\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</DialogFooter>\n\t\t\t\t</form>\n\t\t\t</DialogContent>\n\t\t</Dialog>\n\t);\n}\n\nexport const ImageExtension = (\n\tonImageUpload?: (file: File) => Promise<string>,\n) =>\n\tdefineExtension({\n\t\tname: '@inkcn/image',\n\t\tdependencies: [\n\t\t\tconfigExtension(ReactExtension, {\n\t\t\t\tdecorators: [\n\t\t\t\t\t<ImageDecorator\n\t\t\t\t\t\tkey=\"image\"\n\t\t\t\t\t\tonUploadImage={onImageUpload}\n\t\t\t\t\t/>,\n\t\t\t\t],\n\t\t\t}),\n\t\t],\n\t});\n",
      "type": "registry:component",
      "target": "components/editor/extensions/image-extension.tsx"
    }
  ],
  "type": "registry:block"
}
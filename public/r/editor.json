{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "editor",
  "title": "Editor",
  "description": "A Notion style rich text editor created with Lexical.",
  "dependencies": [
    "@lexical/extension",
    "@lexical/history",
    "@lexical/list",
    "@lexical/react",
    "@lexical/rich-text",
    "@lexical/selection",
    "lexical"
  ],
  "registryDependencies": [
    "toggle-group",
    "button",
    "input",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "registry/new-york/editor/editor-view.tsx",
      "content": "'use client';\n\nimport { ContentEditable } from '@lexical/react/LexicalContentEditable';\nimport { LexicalErrorBoundary } from '@lexical/react/LexicalErrorBoundary';\nimport { LexicalExtensionComposer } from '@lexical/react/LexicalExtensionComposer';\nimport { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin';\nimport { EditorState, LexicalEditor } from 'lexical';\nimport { useState } from 'react';\nimport EditorToolbarPlugin from './editor-toolbar-plugin';\nimport EditorBlockControlPlugin from './editor-block-control-plugin';\nimport { OnChangePlugin } from '@lexical/react/LexicalOnChangePlugin';\nimport { Editor } from '@/lib/Editor';\nimport ReadOnlyPlugin from './readonly-plugin';\n\ninterface EditorViewProps {\n\teditor: Editor;\n\tclassName?: string;\n\tplaceholder?: string;\n\tshowBlockHandle?: boolean;\n\tshowToolbar?: boolean;\n\treadOnly?: boolean;\n\tonChange?: (\n\t\teditorState: EditorState,\n\t\teditor: LexicalEditor,\n\t\ttags: Set<string>,\n\t) => void;\n\tchildren?: React.ReactNode;\n}\n\nexport function EditorView({\n\teditor,\n\tclassName,\n\tplaceholder,\n\tshowBlockHandle = true,\n\tshowToolbar = true,\n\treadOnly = false,\n\tonChange,\n\tchildren,\n}: EditorViewProps) {\n\tconst [floatingAnchorElem, setFloatingAnchorElem] =\n\t\tuseState<HTMLDivElement | null>(null);\n\n\tconst onRef = (_floatingAnchorElem: HTMLDivElement) => {\n\t\tif (_floatingAnchorElem !== null) {\n\t\t\tsetFloatingAnchorElem(_floatingAnchorElem);\n\t\t}\n\t};\n\n\tconst editorPlaceholder =\n\t\tplaceholder ?? \"Enter some text or type '/' for commands\";\n\n\treturn (\n\t\t<LexicalExtensionComposer\n\t\t\textension={editor.lexicalExtension}\n\t\t\tcontentEditable={null}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName={`relative font-normal leading-[1.7] text-foreground ${className ?? ''}`}\n\t\t\t>\n\t\t\t\t<div className=\"relative block bg-background\">\n\t\t\t\t\t<RichTextPlugin\n\t\t\t\t\t\tcontentEditable={\n\t\t\t\t\t\t\t<div className=\"relative z-0 flex min-h-37.5 max-w-full resize-y border-0 outline-none\">\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tref={onRef}\n\t\t\t\t\t\t\t\t\tclassName=\"relative z-0 max-w-full flex-auto resize-y\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<ContentEditable\n\t\t\t\t\t\t\t\t\t\tclassName={`relative min-h-37.5 resize-none px-2.5 py-3.75 text-[15px] caret-foreground outline-none [tab-size:1] ${showBlockHandle ? 'ml-12' : ''}`}\n\t\t\t\t\t\t\t\t\t\taria-placeholder={editorPlaceholder}\n\t\t\t\t\t\t\t\t\t\tplaceholder={\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tclassName={`pointer-events-none absolute top-3.75 inline-block select-none overflow-hidden text-ellipsis text-[15px] text-muted-foreground ${showBlockHandle ? 'left-14.5' : 'left-2.5'}`}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t{editorPlaceholder}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t}\n\t\t\t\t\t\tErrorBoundary={LexicalErrorBoundary}\n\t\t\t\t\t/>\n\t\t\t\t\t{readOnly && <ReadOnlyPlugin />}\n\t\t\t\t\t{floatingAnchorElem && showToolbar && !readOnly && (\n\t\t\t\t\t\t<EditorToolbarPlugin\n\t\t\t\t\t\t\tanchorElem={floatingAnchorElem}\n\t\t\t\t\t\t\toptions={editor.blockPickerOptions}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t{floatingAnchorElem && showBlockHandle && !readOnly && (\n\t\t\t\t\t\t<EditorBlockControlPlugin\n\t\t\t\t\t\t\tanchorElem={floatingAnchorElem}\n\t\t\t\t\t\t\toptions={editor.blockPickerOptions}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t{children}\n\t\t\t\t\t{onChange && <OnChangePlugin onChange={onChange} />}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</LexicalExtensionComposer>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-view.tsx"
    },
    {
      "path": "registry/new-york/editor/editor-toolbar.tsx",
      "content": "'use client';\n\nimport {\n\t$getSelection,\n\t$isRangeSelection,\n\tLexicalEditor,\n\t$isParagraphNode,\n\t$isTextNode,\n\tElementNode,\n\tgetDOMSelection,\n\tRangeSelection,\n\tTextNode,\n\tSELECTION_CHANGE_COMMAND,\n\tCOMMAND_PRIORITY_LOW,\n\tTextFormatType,\n\tFORMAT_TEXT_COMMAND,\n} from 'lexical';\nimport { JSX, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\n\nimport {\n\tBold,\n\tItalic,\n\tUnderline,\n\tStrikethrough,\n\tChevronDown,\n\tBaseline,\n} from 'lucide-react';\n\nimport {\n\tTEXT_COLORS,\n\tBACKGROUND_COLORS,\n\tColorOption,\n} from '@/lib/color-options';\nimport { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group';\nimport {\n\tDropdownMenu,\n\tDropdownMenuContent,\n\tDropdownMenuGroup,\n\tDropdownMenuItem,\n\tDropdownMenuLabel,\n\tDropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu';\nimport { Button } from '@/components/ui/button';\nimport type { BlockCategory, BlockPickerOption } from '@/lib/BlockPickerOption';\nimport { $patchStyleText } from '@lexical/selection';\nimport { $isHeadingNode, $isQuoteNode } from '@lexical/rich-text';\nimport { $isListNode, ListNode } from '@lexical/list';\nimport { $getNearestNodeOfType, mergeRegister } from '@lexical/utils';\nimport {\n\t$getSelectionStyleValueForProperty,\n\t$isAtNodeEnd,\n} from '@lexical/selection';\n\nexport interface TextFormatState {\n\tisBold: boolean;\n\tisItalic: boolean;\n\tisUnderline: boolean;\n\tisStrikethrough: boolean;\n}\n\ninterface UseTextFormatToggleResult {\n\thandleValueChange: (values: string[]) => void;\n\tcurrentValues: string[];\n}\n\nconst FORMATS: TextFormatType[] = [\n\t'bold',\n\t'italic',\n\t'underline',\n\t'strikethrough',\n];\n\nexport function useTextFormatToggle(\n\teditor: LexicalEditor,\n\tformatState: TextFormatState,\n): UseTextFormatToggleResult {\n\tconst { isBold, isItalic, isUnderline, isStrikethrough } = formatState;\n\n\tconst currentValues = useMemo(\n\t\t() => [\n\t\t\t...(isBold ? ['bold'] : []),\n\t\t\t...(isItalic ? ['italic'] : []),\n\t\t\t...(isUnderline ? ['underline'] : []),\n\t\t\t...(isStrikethrough ? ['strikethrough'] : []),\n\t\t],\n\t\t[isBold, isItalic, isUnderline, isStrikethrough],\n\t);\n\n\tconst handleValueChange = useCallback(\n\t\t(values: string[]) => {\n\t\t\tFORMATS.forEach((format) => {\n\t\t\t\tconst isActive =\n\t\t\t\t\tformat === 'bold'\n\t\t\t\t\t\t? isBold\n\t\t\t\t\t\t: format === 'italic'\n\t\t\t\t\t\t\t? isItalic\n\t\t\t\t\t\t\t: format === 'underline'\n\t\t\t\t\t\t\t\t? isUnderline\n\t\t\t\t\t\t\t\t: isStrikethrough;\n\t\t\t\tconst shouldBeActive = values.includes(format);\n\t\t\t\tif (isActive !== shouldBeActive) {\n\t\t\t\t\teditor.dispatchCommand(FORMAT_TEXT_COMMAND, format);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[editor, isBold, isItalic, isUnderline, isStrikethrough],\n\t);\n\n\treturn { handleValueChange, currentValues };\n}\n\nconst VERTICAL_GAP = 10;\nconst HORIZONTAL_OFFSET = 5;\n\ninterface UseFloatingToolbarPositionOptions {\n\teditor: LexicalEditor;\n\tanchorElem: HTMLElement;\n}\n\ninterface UseFloatingToolbarPositionResult {\n\tsetPopupRef: (elem: HTMLDivElement | null) => void;\n}\n\nexport function getDOMRangeRect(\n\tnativeSelection: Selection,\n\trootElement: HTMLElement,\n): DOMRect {\n\tconst domRange = nativeSelection.getRangeAt(0);\n\n\tlet rect;\n\n\tif (nativeSelection.anchorNode === rootElement) {\n\t\tlet inner = rootElement;\n\t\twhile (inner.firstElementChild != null) {\n\t\t\tinner = inner.firstElementChild as HTMLElement;\n\t\t}\n\t\trect = inner.getBoundingClientRect();\n\t} else {\n\t\trect = domRange.getBoundingClientRect();\n\t}\n\n\treturn rect;\n}\n\nexport function setFloatingElemPosition(\n\ttargetRect: DOMRect | null,\n\tfloatingElem: HTMLElement,\n\tanchorElem: HTMLElement,\n\tisLink: boolean = false,\n\tverticalGap: number = VERTICAL_GAP,\n\thorizontalOffset: number = HORIZONTAL_OFFSET,\n): void {\n\tconst scrollerElem = anchorElem.parentElement;\n\n\tif (targetRect === null || !scrollerElem) {\n\t\tfloatingElem.style.opacity = '0';\n\t\tfloatingElem.style.top = '-10000px';\n\t\tfloatingElem.style.left = '-10000px';\n\t\treturn;\n\t}\n\n\tconst floatingElemRect = floatingElem.getBoundingClientRect();\n\tconst anchorElementRect = anchorElem.getBoundingClientRect();\n\tconst editorScrollerRect = scrollerElem.getBoundingClientRect();\n\n\tlet top = targetRect.top - floatingElemRect.height - verticalGap;\n\tlet left = targetRect.left - horizontalOffset;\n\n\tconst selection = window.getSelection();\n\tif (selection && selection.rangeCount > 0) {\n\t\tconst range = selection.getRangeAt(0);\n\t\tconst textNode = range.startContainer;\n\t\tif (textNode.nodeType === Node.ELEMENT_NODE || textNode.parentElement) {\n\t\t\tconst textElement =\n\t\t\t\ttextNode.nodeType === Node.ELEMENT_NODE\n\t\t\t\t\t? (textNode as Element)\n\t\t\t\t\t: (textNode.parentElement as Element);\n\t\t\tconst textAlign = window.getComputedStyle(textElement).textAlign;\n\n\t\t\tif (textAlign === 'right' || textAlign === 'end') {\n\t\t\t\tleft =\n\t\t\t\t\ttargetRect.right -\n\t\t\t\t\tfloatingElemRect.width +\n\t\t\t\t\thorizontalOffset;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (top < editorScrollerRect.top) {\n\t\ttop +=\n\t\t\tfloatingElemRect.height +\n\t\t\ttargetRect.height +\n\t\t\tverticalGap * (isLink ? 9 : 2);\n\t}\n\n\tif (left + floatingElemRect.width > editorScrollerRect.right) {\n\t\tleft =\n\t\t\teditorScrollerRect.right -\n\t\t\tfloatingElemRect.width -\n\t\t\thorizontalOffset;\n\t}\n\n\tif (left < editorScrollerRect.left) {\n\t\tleft = editorScrollerRect.left + horizontalOffset;\n\t}\n\n\ttop -= anchorElementRect.top;\n\tleft -= anchorElementRect.left;\n\n\tfloatingElem.style.opacity = '1';\n\tfloatingElem.style.top = `${top}px`;\n\tfloatingElem.style.left = `${left}px`;\n}\n\nexport function useFloatingToolbarPosition({\n\teditor,\n\tanchorElem,\n}: UseFloatingToolbarPositionOptions): UseFloatingToolbarPositionResult {\n\tconst popupRef = useRef<HTMLDivElement | null>(null);\n\n\tconst updatePosition = useCallback(() => {\n\t\tconst popupElem = popupRef.current;\n\t\tconst nativeSelection = getDOMSelection(editor._window);\n\n\t\tif (popupElem === null) return;\n\n\t\tconst rootElement = editor.getRootElement();\n\t\tconst selection = $getSelection();\n\n\t\tif (\n\t\t\tselection !== null &&\n\t\t\tnativeSelection !== null &&\n\t\t\t!nativeSelection.isCollapsed &&\n\t\t\trootElement !== null &&\n\t\t\trootElement.contains(nativeSelection.anchorNode)\n\t\t) {\n\t\t\tconst rangeRect = getDOMRangeRect(nativeSelection, rootElement);\n\t\t\tsetFloatingElemPosition(rangeRect, popupElem, anchorElem, false);\n\t\t}\n\t}, [editor, anchorElem]);\n\n\tconst setPopupRef = useCallback(\n\t\t(elem: HTMLDivElement | null) => {\n\t\t\tpopupRef.current = elem;\n\t\t\tif (elem) {\n\t\t\t\teditor.getEditorState().read(() => {\n\t\t\t\t\tupdatePosition();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[editor, updatePosition],\n\t);\n\n\t// Mouse event handlers for pointer events during drag\n\tuseEffect(() => {\n\t\tfunction mouseMoveListener(e: MouseEvent) {\n\t\t\tif (popupRef.current && (e.buttons === 1 || e.buttons === 2)) {\n\t\t\t\tif (popupRef.current.style.pointerEvents !== 'none') {\n\t\t\t\t\tconst elementUnderMouse = document.elementFromPoint(\n\t\t\t\t\t\te.clientX,\n\t\t\t\t\t\te.clientY,\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\telementUnderMouse &&\n\t\t\t\t\t\t!popupRef.current.contains(elementUnderMouse)\n\t\t\t\t\t) {\n\t\t\t\t\t\tpopupRef.current.style.pointerEvents = 'none';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction mouseUpListener() {\n\t\t\tif (!popupRef.current) return;\n\t\t\tif (popupRef.current.style.pointerEvents !== 'auto') {\n\t\t\t\tpopupRef.current.style.pointerEvents = 'auto';\n\t\t\t}\n\t\t}\n\n\t\tdocument.addEventListener('mousemove', mouseMoveListener);\n\t\tdocument.addEventListener('mouseup', mouseUpListener);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('mousemove', mouseMoveListener);\n\t\t\tdocument.removeEventListener('mouseup', mouseUpListener);\n\t\t};\n\t}, []);\n\n\t// Scroll and resize listeners\n\tuseEffect(() => {\n\t\tconst scrollerElem = anchorElem.parentElement;\n\n\t\tconst update = () => {\n\t\t\teditor.getEditorState().read(() => {\n\t\t\t\tupdatePosition();\n\t\t\t});\n\t\t};\n\n\t\twindow.addEventListener('resize', update);\n\t\tscrollerElem?.addEventListener('scroll', update);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener('resize', update);\n\t\t\tscrollerElem?.removeEventListener('scroll', update);\n\t\t};\n\t}, [editor, updatePosition, anchorElem]);\n\n\t// Editor state and selection listeners\n\tuseEffect(() => {\n\t\teditor.getEditorState().read(() => {\n\t\t\tupdatePosition();\n\t\t});\n\n\t\treturn mergeRegister(\n\t\t\teditor.registerUpdateListener(({ editorState }) => {\n\t\t\t\teditorState.read(() => {\n\t\t\t\t\tupdatePosition();\n\t\t\t\t});\n\t\t\t}),\n\t\t\teditor.registerCommand(\n\t\t\t\tSELECTION_CHANGE_COMMAND,\n\t\t\t\t() => {\n\t\t\t\t\tupdatePosition();\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t);\n\t}, [editor, updatePosition]);\n\n\treturn { setPopupRef };\n}\n\nexport type EditorToolbarState = {\n\tisVisible: boolean;\n\tisBold: boolean;\n\tisItalic: boolean;\n\tisUnderline: boolean;\n\tisUppercase: boolean;\n\tisLowercase: boolean;\n\tisCapitalize: boolean;\n\tisStrikethrough: boolean;\n\tisSubscript: boolean;\n\tisSuperscript: boolean;\n\tblockType: string;\n\tfontColor: string;\n\tbgColor: string;\n};\n\nconst DEFAULT_STATE: EditorToolbarState = {\n\tisVisible: false,\n\tisBold: false,\n\tisItalic: false,\n\tisUnderline: false,\n\tisUppercase: false,\n\tisLowercase: false,\n\tisCapitalize: false,\n\tisStrikethrough: false,\n\tisSubscript: false,\n\tisSuperscript: false,\n\tblockType: 'paragraph',\n\tfontColor: '',\n\tbgColor: '',\n};\n\nexport function getSelectedNode(\n\tselection: RangeSelection,\n): TextNode | ElementNode {\n\tconst anchor = selection.anchor;\n\tconst focus = selection.focus;\n\tconst anchorNode = selection.anchor.getNode();\n\tconst focusNode = selection.focus.getNode();\n\tif (anchorNode === focusNode) {\n\t\treturn anchorNode;\n\t}\n\tconst isBackward = selection.isBackward();\n\tif (isBackward) {\n\t\treturn $isAtNodeEnd(focus) ? anchorNode : focusNode;\n\t} else {\n\t\treturn $isAtNodeEnd(anchor) ? anchorNode : focusNode;\n\t}\n}\n\nfunction $getBlockType(\n\teditor: LexicalEditor,\n\tselection: ReturnType<typeof $getSelection>,\n): string {\n\tif (!$isRangeSelection(selection)) return 'paragraph';\n\n\tconst anchorNode = selection.anchor.getNode();\n\tconst element =\n\t\tanchorNode.getKey() === 'root'\n\t\t\t? anchorNode\n\t\t\t: anchorNode.getTopLevelElementOrThrow();\n\n\tconst elementDOM = editor.getElementByKey(element.getKey());\n\tif (elementDOM === null) return 'paragraph';\n\n\tif ($isListNode(element)) {\n\t\tconst parentList = $getNearestNodeOfType<ListNode>(\n\t\t\tanchorNode,\n\t\t\tListNode,\n\t\t);\n\t\tconst type = parentList\n\t\t\t? parentList.getListType()\n\t\t\t: element.getListType();\n\t\tif (type === 'number') return 'ordered-list';\n\t\tif (type === 'check') return 'check-list';\n\t\treturn 'unordered-list';\n\t}\n\n\tif ($isHeadingNode(element)) {\n\t\tconst tag = element.getTag();\n\t\treturn `heading-${tag.replace('h', '')}`;\n\t}\n\n\tif ($isQuoteNode(element)) return 'quote';\n\n\treturn 'paragraph';\n}\n\nexport function useEditorToolbar(editor: LexicalEditor): EditorToolbarState {\n\tconst [toolbarState, setEditorToolbarState] =\n\t\tuseState<EditorToolbarState>(DEFAULT_STATE);\n\tconst isMouseDownRef = useRef(false);\n\n\tconst update = useCallback(\n\t\t(forceShow = false) => {\n\t\t\teditor.getEditorState().read(() => {\n\t\t\t\tif (editor.isComposing()) return;\n\n\t\t\t\tif (isMouseDownRef.current && !forceShow) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tconst nativeSelection = getDOMSelection(editor._window);\n\t\t\t\tconst rootElement = editor.getRootElement();\n\n\t\t\t\tif (\n\t\t\t\t\tnativeSelection !== null &&\n\t\t\t\t\t(!$isRangeSelection(selection) ||\n\t\t\t\t\t\trootElement === null ||\n\t\t\t\t\t\t!rootElement.contains(nativeSelection.anchorNode))\n\t\t\t\t) {\n\t\t\t\t\tsetEditorToolbarState(DEFAULT_STATE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!$isRangeSelection(selection)) return;\n\n\t\t\t\tconst node = getSelectedNode(selection);\n\n\t\t\t\tconst hasText = selection.getTextContent() !== '';\n\t\t\t\tconst isText =\n\t\t\t\t\thasText && ($isTextNode(node) || $isParagraphNode(node));\n\n\t\t\t\tconst rawTextContent = selection\n\t\t\t\t\t.getTextContent()\n\t\t\t\t\t.replace(/\\n/g, '');\n\t\t\t\tconst isCollapsedWhitespaceSelection =\n\t\t\t\t\t!selection.isCollapsed() && rawTextContent === '';\n\n\t\t\t\tif (!isText || isCollapsedWhitespaceSelection) {\n\t\t\t\t\tsetEditorToolbarState(DEFAULT_STATE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tsetEditorToolbarState({\n\t\t\t\t\tisVisible: true,\n\t\t\t\t\tisBold: selection.hasFormat('bold'),\n\t\t\t\t\tisItalic: selection.hasFormat('italic'),\n\t\t\t\t\tisUnderline: selection.hasFormat('underline'),\n\t\t\t\t\tisUppercase: selection.hasFormat('uppercase'),\n\t\t\t\t\tisLowercase: selection.hasFormat('lowercase'),\n\t\t\t\t\tisCapitalize: selection.hasFormat('capitalize'),\n\t\t\t\t\tisStrikethrough: selection.hasFormat('strikethrough'),\n\t\t\t\t\tisSubscript: selection.hasFormat('subscript'),\n\t\t\t\t\tisSuperscript: selection.hasFormat('superscript'),\n\t\t\t\t\tblockType: $getBlockType(editor, selection),\n\t\t\t\t\tfontColor: $getSelectionStyleValueForProperty(\n\t\t\t\t\t\tselection,\n\t\t\t\t\t\t'color',\n\t\t\t\t\t\t'',\n\t\t\t\t\t),\n\t\t\t\t\tbgColor: $getSelectionStyleValueForProperty(\n\t\t\t\t\t\tselection,\n\t\t\t\t\t\t'background-color',\n\t\t\t\t\t\t'',\n\t\t\t\t\t),\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\t[editor],\n\t);\n\n\tuseEffect(() => {\n\t\tconst rootElement = editor.getRootElement();\n\t\tif (!rootElement) return;\n\n\t\tconst handleMouseDown = () => {\n\t\t\tisMouseDownRef.current = true;\n\t\t\tsetEditorToolbarState(DEFAULT_STATE);\n\t\t};\n\n\t\tconst handleMouseUp = () => {\n\t\t\tisMouseDownRef.current = false;\n\t\t\tupdate(true);\n\t\t};\n\n\t\trootElement.addEventListener('mousedown', handleMouseDown);\n\t\tdocument.addEventListener('mouseup', handleMouseUp);\n\n\t\treturn () => {\n\t\t\trootElement.removeEventListener('mousedown', handleMouseDown);\n\t\t\tdocument.removeEventListener('mouseup', handleMouseUp);\n\t\t};\n\t}, [editor, update]);\n\n\tuseEffect(() => {\n\t\tdocument.addEventListener('selectionchange', () => update());\n\t\treturn () =>\n\t\t\tdocument.removeEventListener('selectionchange', () => update());\n\t}, [update]);\n\n\tuseEffect(() => {\n\t\treturn mergeRegister(\n\t\t\teditor.registerUpdateListener(() => update()),\n\t\t\teditor.registerRootListener(() => {\n\t\t\t\tif (editor.getRootElement() === null) {\n\t\t\t\t\tsetEditorToolbarState(DEFAULT_STATE);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\t}, [editor, update]);\n\n\treturn toolbarState;\n}\n\nexport function useColorFormat(editor: LexicalEditor) {\n\tconst applyFontColor = useCallback(\n\t\t(color: string | null) => {\n\t\t\teditor.update(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t$patchStyleText(selection, { color });\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[editor],\n\t);\n\n\tconst applyBgColor = useCallback(\n\t\t(color: string | null) => {\n\t\t\teditor.update(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t$patchStyleText(selection, { 'background-color': color });\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[editor],\n\t);\n\n\treturn { applyFontColor, applyBgColor };\n}\n\nconst TOOLBAR_BLOCK_CATEGORIES: BlockCategory[] = [\n\t'basic',\n\t'headings',\n\t'lists',\n\t'quotes',\n];\n\nexport function filterBlockOptions(\n\toptions: BlockPickerOption[],\n): BlockPickerOption[] {\n\treturn options.filter((opt) =>\n\t\tTOOLBAR_BLOCK_CATEGORIES.includes(opt.category),\n\t);\n}\n\ninterface EditorToolbarProps {\n\teditor: LexicalEditor;\n\tanchorElem: HTMLElement;\n\toptions: BlockPickerOption[];\n}\n\nexport default function EditorToolbar({\n\teditor,\n\tanchorElem,\n\toptions,\n}: EditorToolbarProps): JSX.Element | null {\n\tconst state = useEditorToolbar(editor);\n\tconst { setPopupRef } = useFloatingToolbarPosition({ editor, anchorElem });\n\tconst { handleValueChange: onTextStyleToggle, currentValues } =\n\t\tuseTextFormatToggle(editor, state);\n\tconst { applyFontColor, applyBgColor } = useColorFormat(editor);\n\n\tif (!state.isVisible) return null;\n\n\tconst currentBlock = options.find((opt) => opt.key === state.blockType);\n\tconst blockOptions = filterBlockOptions(options);\n\n\treturn createPortal(\n\t\t<div\n\t\t\tref={setPopupRef}\n\t\t\tclassName=\"absolute z-50 flex items-center gap-0.5 rounded-md border bg-popover p-1 shadow-md animate-in fade-in-0 zoom-in-95 slide-in-from-bottom-2 duration-150\"\n\t\t>\n\t\t\t{/* Block picker dropdown */}\n\t\t\t<DropdownMenu>\n\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t<Button variant=\"ghost\">\n\t\t\t\t\t\t{currentBlock?.icon}\n\t\t\t\t\t\t<span>{currentBlock?.title ?? 'Paragraph'}</span>\n\t\t\t\t\t\t<ChevronDown className=\"h-3 w-3\" />\n\t\t\t\t\t</Button>\n\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t<DropdownMenuContent align=\"start\">\n\t\t\t\t\t{blockOptions.map((option) => (\n\t\t\t\t\t\t<DropdownMenuItem\n\t\t\t\t\t\t\tkey={option.key}\n\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\toption.insert({ editor, queryString: '' });\n\t\t\t\t\t\t\t\teditor.update(() => {\n\t\t\t\t\t\t\t\t\tconst selection = $getSelection();\n\t\t\t\t\t\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t\t\t\t\t\tselection.focus.set(\n\t\t\t\t\t\t\t\t\t\t\tselection.anchor.key,\n\t\t\t\t\t\t\t\t\t\t\tselection.anchor.offset,\n\t\t\t\t\t\t\t\t\t\t\tselection.anchor.type,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\t\tstate.blockType === option.key\n\t\t\t\t\t\t\t\t\t? 'bg-accent'\n\t\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"mr-2 h-4 w-4\">{option.icon}</span>\n\t\t\t\t\t\t\t{option.title}\n\t\t\t\t\t\t</DropdownMenuItem>\n\t\t\t\t\t))}\n\t\t\t\t</DropdownMenuContent>\n\t\t\t</DropdownMenu>\n\n\t\t\t{/* Text format toggles */}\n\t\t\t<ToggleGroup\n\t\t\t\ttype=\"multiple\"\n\t\t\t\tspacing={1}\n\t\t\t\tvalue={currentValues}\n\t\t\t\tonValueChange={onTextStyleToggle}\n\t\t\t>\n\t\t\t\t<ToggleGroupItem\n\t\t\t\t\tvalue=\"bold\"\n\t\t\t\t\ttitle=\"Bold\"\n\t\t\t\t\taria-label=\"Format text as bold\"\n\t\t\t\t>\n\t\t\t\t\t<Bold className=\"h-2 w-2\" />\n\t\t\t\t</ToggleGroupItem>\n\n\t\t\t\t<ToggleGroupItem\n\t\t\t\t\tvalue=\"italic\"\n\t\t\t\t\ttitle=\"Italic\"\n\t\t\t\t\taria-label=\"Format text as italics\"\n\t\t\t\t>\n\t\t\t\t\t<Italic className=\"h-2 w-2\" />\n\t\t\t\t</ToggleGroupItem>\n\n\t\t\t\t<ToggleGroupItem\n\t\t\t\t\tvalue=\"underline\"\n\t\t\t\t\ttitle=\"Underline\"\n\t\t\t\t\taria-label=\"Format text to underlined\"\n\t\t\t\t>\n\t\t\t\t\t<Underline className=\"h-2 w-2\" />\n\t\t\t\t</ToggleGroupItem>\n\n\t\t\t\t<ToggleGroupItem\n\t\t\t\t\tvalue=\"strikethrough\"\n\t\t\t\t\ttitle=\"Strikethrough\"\n\t\t\t\t\taria-label=\"Format text with a strikethrough\"\n\t\t\t\t>\n\t\t\t\t\t<Strikethrough className=\"h-2 w-2\" />\n\t\t\t\t</ToggleGroupItem>\n\t\t\t</ToggleGroup>\n\n\t\t\t{/* Color picker dropdown */}\n\t\t\t<DropdownMenu>\n\t\t\t\t<DropdownMenuTrigger asChild>\n\t\t\t\t\t<Button\n\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\tstate.bgColor\n\t\t\t\t\t\t\t\t? { backgroundColor: state.bgColor }\n\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Baseline\n\t\t\t\t\t\t\tclassName=\"h-3 w-3\"\n\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\tstate.fontColor\n\t\t\t\t\t\t\t\t\t? { color: state.fontColor }\n\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Button>\n\t\t\t\t</DropdownMenuTrigger>\n\t\t\t\t<DropdownMenuContent>\n\t\t\t\t\t<ColorMenuGroup\n\t\t\t\t\t\tlabel=\"Text\"\n\t\t\t\t\t\tcolors={TEXT_COLORS}\n\t\t\t\t\t\tactiveValue={state.fontColor}\n\t\t\t\t\t\tonSelect={applyFontColor}\n\t\t\t\t\t/>\n\t\t\t\t\t<ColorMenuGroup\n\t\t\t\t\t\tlabel=\"Background\"\n\t\t\t\t\t\tcolors={BACKGROUND_COLORS}\n\t\t\t\t\t\tactiveValue={state.bgColor}\n\t\t\t\t\t\tonSelect={applyBgColor}\n\t\t\t\t\t/>\n\t\t\t\t</DropdownMenuContent>\n\t\t\t</DropdownMenu>\n\t\t</div>,\n\t\tanchorElem,\n\t);\n}\n\nfunction ColorMenuGroup({\n\tlabel,\n\tcolors,\n\tactiveValue,\n\tonSelect,\n}: {\n\tlabel: string;\n\tcolors: ColorOption[];\n\tactiveValue: string;\n\tonSelect: (color: string | null) => void;\n}) {\n\treturn (\n\t\t<DropdownMenuGroup>\n\t\t\t<DropdownMenuLabel>{label}</DropdownMenuLabel>\n\t\t\t{colors.map((color) => (\n\t\t\t\t<DropdownMenuItem\n\t\t\t\t\tkey={color.key}\n\t\t\t\t\tonSelect={() => onSelect(color.value)}\n\t\t\t\t\tclassName={\n\t\t\t\t\t\t(color.value ?? '') === activeValue ? 'bg-accent' : ''\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t\t<Baseline className={`h-3 w-3 ${color.iconClassName}`} />\n\t\t\t\t\t{color.label}\n\t\t\t\t</DropdownMenuItem>\n\t\t\t))}\n\t\t</DropdownMenuGroup>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-toolbar.tsx"
    },
    {
      "path": "registry/new-york/editor/editor-toolbar-plugin.tsx",
      "content": "import type { JSX } from 'react';\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport EditorToolbar from './editor-toolbar';\nimport { BlockPickerOption } from '@/lib/BlockPickerOption';\n\nexport default function EditorToolbarPlugin({\n\tanchorElem = document.body,\n\toptions,\n}: {\n\tanchorElem?: HTMLElement;\n\toptions: BlockPickerOption[];\n}): JSX.Element | null {\n\tconst [editor] = useLexicalComposerContext();\n\treturn (\n\t\t<EditorToolbar\n\t\t\teditor={editor}\n\t\t\tanchorElem={anchorElem}\n\t\t\toptions={options}\n\t\t/>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-toolbar-plugin.tsx"
    },
    {
      "path": "registry/new-york/editor/readonly-plugin.tsx",
      "content": "import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useEffect } from 'react';\n\nexport default function ReadOnlyPlugin() {\n\tconst [editor] = useLexicalComposerContext();\n\tuseEffect(() => {\n\t\teditor.setEditable(false);\n\t\treturn () => {\n\t\t\teditor.setEditable(true);\n\t\t};\n\t}, [editor]);\n\treturn null;\n}\n",
      "type": "registry:component",
      "target": "components/editor/readonly-plugin.tsx"
    },
    {
      "path": "registry/new-york/editor/editor-block-control-plugin.tsx",
      "content": "'use client';\n\nimport type { NodeKey } from 'lexical';\nimport type { JSX } from 'react';\n\nimport { DraggableBlockPlugin_EXPERIMENTAL } from '@lexical/react/LexicalDraggableBlockPlugin';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport {\n\t$createParagraphNode,\n\t$createTextNode,\n\t$getNearestNodeFromDOMNode,\n\t$getNodeByKey,\n\t$isParagraphNode,\n\t$isTextNode,\n} from 'lexical';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport { GripVertical, Plus } from 'lucide-react';\n\nimport { BlockPickerOption } from '@/lib/BlockPickerOption';\nimport { BlockPickerMenu } from './block-picker-menu';\n\nconst DRAGGABLE_BLOCK_MENU_CLASSNAME = 'draggable-block-menu';\n\ntype PickerState = {\n\tparagraphKey: NodeKey;\n};\n\ntype BlockControlPluginProps = {\n\tanchorElem?: HTMLElement;\n\toptions?: BlockPickerOption[];\n};\n\nfunction isOnMenu(element: HTMLElement): boolean {\n\treturn !!element.closest(`.${DRAGGABLE_BLOCK_MENU_CLASSNAME}`);\n}\n\nexport default function EditorBlockControlPlugin({\n\tanchorElem = document.body,\n\toptions = [],\n}: BlockControlPluginProps): JSX.Element {\n\tconst [editor] = useLexicalComposerContext();\n\tconst menuRef = useRef<HTMLDivElement>(null);\n\tconst pickerRef = useRef<HTMLDivElement>(null);\n\tconst targetLineRef = useRef<HTMLDivElement>(null);\n\tconst [draggableElement, setDraggableElement] =\n\t\tuseState<HTMLElement | null>(null);\n\tconst [pickerState, setPickerState] = useState<PickerState | null>(null);\n\tconst [isPickerOpen, setIsPickerOpen] = useState(false);\n\tconst [queryString, setQueryString] = useState('');\n\tconst [highlightedIndex, setHighlightedIndex] = useState(0);\n\tconst [pickerPosition, setPickerPosition] = useState<{\n\t\tleft: number;\n\t\ttop: number;\n\t\tanchor: 'top' | 'bottom';\n\t} | null>(null);\n\n\tconst filteredOptions = useMemo(() => {\n\t\tif (!queryString) return options;\n\t\tconst regex = new RegExp(queryString, 'i');\n\t\treturn options.filter(\n\t\t\t(option) =>\n\t\t\t\tregex.test(option.title) ||\n\t\t\t\toption.keywords.some((keyword) => regex.test(keyword)),\n\t\t);\n\t}, [options, queryString]);\n\n\tconst clampedIndex =\n\t\tfilteredOptions.length > 0\n\t\t\t? Math.min(highlightedIndex, filteredOptions.length - 1)\n\t\t\t: 0;\n\n\t// Close on click outside\n\tuseEffect(() => {\n\t\tif (!isPickerOpen) return;\n\t\tconst handleClickOutside = (event: MouseEvent) => {\n\t\t\tconst target = event.target as Node | null;\n\t\t\tif (\n\t\t\t\t(pickerRef.current && pickerRef.current.contains(target)) ||\n\t\t\t\t(menuRef.current && menuRef.current.contains(target))\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetIsPickerOpen(false);\n\t\t\tsetPickerState(null);\n\t\t};\n\t\tdocument.addEventListener('mousedown', handleClickOutside);\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('mousedown', handleClickOutside);\n\t\t};\n\t}, [isPickerOpen]);\n\n\tconst selectOption = useCallback(\n\t\t(option: BlockPickerOption) => {\n\t\t\tif (!pickerState) {\n\t\t\t\tsetIsPickerOpen(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsetIsPickerOpen(false);\n\t\t\tsetPickerState(null);\n\t\t\teditor.update(() => {\n\t\t\t\tconst node = $getNodeByKey(pickerState.paragraphKey);\n\t\t\t\tif (!node || !$isParagraphNode(node)) return;\n\n\t\t\t\t// Select into the existing paragraph so the insert replaces it\n\t\t\t\tconst firstChild = node.getFirstChild();\n\t\t\t\tif ($isTextNode(firstChild)) {\n\t\t\t\t\tfirstChild.select();\n\t\t\t\t}\n\n\t\t\t\toption.insert({ editor, queryString });\n\n\t\t\t\t// Clean up empty placeholder if the insert didn't use it\n\t\t\t\tconst latest = node.getLatest();\n\t\t\t\tif ($isParagraphNode(latest)) {\n\t\t\t\t\tconst onlyChild = latest.getFirstChild();\n\t\t\t\t\tif (\n\t\t\t\t\t\t$isTextNode(onlyChild) &&\n\t\t\t\t\t\tonlyChild.getTextContent().length === 0 &&\n\t\t\t\t\t\tlatest.getChildrenSize() === 1\n\t\t\t\t\t) {\n\t\t\t\t\t\tlatest.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[editor, pickerState, queryString],\n\t);\n\n\t// Keyboard navigation\n\tuseEffect(() => {\n\t\tif (!isPickerOpen) return;\n\t\tconst handleKeyDown = (event: KeyboardEvent) => {\n\t\t\tif (!filteredOptions.length) return;\n\t\t\tif (event.key === 'ArrowDown') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetHighlightedIndex((i) =>\n\t\t\t\t\ti + 1 >= filteredOptions.length ? 0 : i + 1,\n\t\t\t\t);\n\t\t\t} else if (event.key === 'ArrowUp') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetHighlightedIndex((i) =>\n\t\t\t\t\ti - 1 < 0 ? filteredOptions.length - 1 : i - 1,\n\t\t\t\t);\n\t\t\t} else if (event.key === 'Enter') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst option = filteredOptions[clampedIndex];\n\t\t\t\tif (option) selectOption(option);\n\t\t\t} else if (event.key === 'Escape') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tsetIsPickerOpen(false);\n\t\t\t\tsetPickerState(null);\n\t\t\t}\n\t\t};\n\t\twindow.addEventListener('keydown', handleKeyDown);\n\t\treturn () => window.removeEventListener('keydown', handleKeyDown);\n\t}, [clampedIndex, isPickerOpen, filteredOptions, selectOption]);\n\n\tfunction openPicker() {\n\t\tif (!draggableElement || !editor) return;\n\n\t\tlet paragraphKey: NodeKey | null = null;\n\n\t\teditor.update(() => {\n\t\t\tconst node = $getNearestNodeFromDOMNode(draggableElement);\n\t\t\tif (!node) return;\n\n\t\t\tconst paragraph = $createParagraphNode();\n\t\t\tconst textNode = $createTextNode('');\n\t\t\tparagraph.append(textNode);\n\t\t\tnode.insertAfter(paragraph);\n\t\t\ttextNode.select();\n\t\t\tparagraphKey = paragraph.getKey();\n\t\t});\n\n\t\tif (!paragraphKey) return;\n\n\t\t// Wait for DOM to update, then position picker at the new paragraph\n\t\trequestAnimationFrame(() => {\n\t\t\tconst paragraphDom = editor.getElementByKey(paragraphKey!);\n\t\t\tif (!paragraphDom) return;\n\n\t\t\tconst rect = paragraphDom.getBoundingClientRect();\n\t\t\tconst PICKER_HEIGHT = 300;\n\t\t\tconst spaceBelow = window.innerHeight - rect.bottom;\n\t\t\tconst showAbove =\n\t\t\t\tspaceBelow < PICKER_HEIGHT && rect.top > PICKER_HEIGHT;\n\n\t\t\tsetPickerPosition({\n\t\t\t\tleft: rect.left,\n\t\t\t\ttop: showAbove ? rect.top : rect.bottom + 4,\n\t\t\t\tanchor: showAbove ? 'bottom' : 'top',\n\t\t\t});\n\t\t\tsetPickerState({ paragraphKey: paragraphKey! });\n\t\t\tsetQueryString('');\n\t\t\tsetHighlightedIndex(0);\n\t\t\tsetIsPickerOpen(true);\n\t\t});\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t{isPickerOpen && pickerPosition\n\t\t\t\t? createPortal(\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tref={pickerRef}\n\t\t\t\t\t\t\tclassName=\"fixed z-50\"\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\tleft: pickerPosition.left,\n\t\t\t\t\t\t\t\t...(pickerPosition.anchor === 'bottom'\n\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\tbottom:\n\t\t\t\t\t\t\t\t\t\t\t\twindow.innerHeight -\n\t\t\t\t\t\t\t\t\t\t\t\tpickerPosition.top,\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t: { top: pickerPosition.top }),\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<BlockPickerMenu\n\t\t\t\t\t\t\t\toptions={filteredOptions}\n\t\t\t\t\t\t\t\tselectedIndex={clampedIndex}\n\t\t\t\t\t\t\t\tonSelectOption={(option) => {\n\t\t\t\t\t\t\t\t\tselectOption(option);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonSetHighlightedIndex={setHighlightedIndex}\n\t\t\t\t\t\t\t\tqueryString={queryString}\n\t\t\t\t\t\t\t\tonQueryChange={(q) => {\n\t\t\t\t\t\t\t\t\tsetQueryString(q);\n\t\t\t\t\t\t\t\t\tsetHighlightedIndex(0);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>,\n\t\t\t\t\t\tdocument.body,\n\t\t\t\t\t)\n\t\t\t\t: null}\n\t\t\t<DraggableBlockPlugin_EXPERIMENTAL\n\t\t\t\tanchorElem={anchorElem}\n\t\t\t\tmenuRef={menuRef}\n\t\t\t\ttargetLineRef={targetLineRef}\n\t\t\t\tmenuComponent={\n\t\t\t\t\t<div\n\t\t\t\t\t\tref={menuRef}\n\t\t\t\t\t\tclassName={`${DRAGGABLE_BLOCK_MENU_CLASSNAME} group flex items-center gap-0.5 rounded p-0.5 px-px opacity-0 absolute left-0 top-0 will-change-transform`}\n\t\t\t\t\t>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\ttitle=\"Click to add below, hold Alt/Ctrl to add above\"\n\t\t\t\t\t\t\tclassName=\"flex items-center justify-center w-6 h-6 p-0 border-none bg-transparent cursor-pointer opacity-30 rounded text-foreground group-hover:opacity-60 hover:opacity-100! hover:bg-accent\"\n\t\t\t\t\t\t\taria-label=\"Add block\"\n\t\t\t\t\t\t\tonClick={openPicker}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Plus size={18} />\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<div className=\"flex items-center justify-center w-6 h-6 opacity-30 cursor-grab active:cursor-grabbing rounded text-foreground group-hover:opacity-60 hover:opacity-100! hover:bg-accent\">\n\t\t\t\t\t\t\t<GripVertical size={18} />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t}\n\t\t\t\ttargetLineComponent={\n\t\t\t\t\t<div\n\t\t\t\t\t\tref={targetLineRef}\n\t\t\t\t\t\tclassName=\"pointer-events-none bg-ring h-1 absolute left-0 top-0 opacity-0 will-change-transform\"\n\t\t\t\t\t/>\n\t\t\t\t}\n\t\t\t\tisOnMenu={isOnMenu}\n\t\t\t\tonElementChanged={setDraggableElement}\n\t\t\t/>\n\t\t</>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-block-control-plugin.tsx"
    },
    {
      "path": "registry/new-york/editor/editor-block-picker-plugin.tsx",
      "content": "import type { JSX } from 'react';\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport {\n\tLexicalTypeaheadMenuPlugin,\n\tuseBasicTypeaheadTriggerMatch,\n} from '@lexical/react/LexicalTypeaheadMenuPlugin';\nimport { TextNode } from 'lexical';\nimport { useCallback, useMemo, useState } from 'react';\nimport * as ReactDOM from 'react-dom';\n\nimport { BlockPickerOption } from '@/lib/BlockPickerOption';\nimport { BlockPickerMenu } from './block-picker-menu';\n\ntype BlockPickerPluginProps = {\n\toptions: BlockPickerOption[];\n};\n\nexport default function BlockPickerPlugin({\n\toptions,\n}: BlockPickerPluginProps): JSX.Element {\n\tconst [editor] = useLexicalComposerContext();\n\n\tconst [queryString, setQueryString] = useState<string | null>(null);\n\n\tconst checkForTriggerMatch = useBasicTypeaheadTriggerMatch('/', {\n\t\tallowWhitespace: true,\n\t\tminLength: 0,\n\t});\n\n\tconst filteredOptions = useMemo(() => {\n\t\tif (!queryString) return options;\n\n\t\tconst regex = new RegExp(queryString, 'i');\n\n\t\treturn options.filter((option) => {\n\t\t\treturn (\n\t\t\t\tregex.test(option.title) ||\n\t\t\t\toption.keywords.some((keyword: string) => regex.test(keyword))\n\t\t\t);\n\t\t});\n\t}, [options, queryString]);\n\n\tconst onSelectOption = useCallback(\n\t\t(\n\t\t\tselectedOption: BlockPickerOption,\n\t\t\tnodeToRemove: TextNode | null,\n\t\t\tcloseMenu: () => void,\n\t\t\tmatchingString: string,\n\t\t) => {\n\t\t\teditor.update(() => {\n\t\t\t\tnodeToRemove?.remove();\n\t\t\t\tselectedOption.insert({\n\t\t\t\t\teditor,\n\t\t\t\t\tqueryString: matchingString,\n\t\t\t\t});\n\t\t\t\tcloseMenu();\n\t\t\t});\n\t\t},\n\t\t[editor],\n\t);\n\n\treturn (\n\t\t<>\n\t\t\t<LexicalTypeaheadMenuPlugin<BlockPickerOption>\n\t\t\t\tonQueryChange={setQueryString}\n\t\t\t\tonSelectOption={onSelectOption}\n\t\t\t\ttriggerFn={checkForTriggerMatch}\n\t\t\t\toptions={filteredOptions}\n\t\t\t\tmenuRenderFn={(\n\t\t\t\t\tanchorElementRef,\n\t\t\t\t\t{\n\t\t\t\t\t\tselectedIndex,\n\t\t\t\t\t\tselectOptionAndCleanUp,\n\t\t\t\t\t\tsetHighlightedIndex,\n\t\t\t\t\t},\n\t\t\t\t) =>\n\t\t\t\t\tanchorElementRef.current && filteredOptions.length\n\t\t\t\t\t\t? ReactDOM.createPortal(\n\t\t\t\t\t\t\t\t<BlockPickerMenu\n\t\t\t\t\t\t\t\t\toptions={filteredOptions}\n\t\t\t\t\t\t\t\t\tselectedIndex={selectedIndex}\n\t\t\t\t\t\t\t\t\tonSelectOption={(option) => {\n\t\t\t\t\t\t\t\t\t\tselectOptionAndCleanUp(option);\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\tonSetHighlightedIndex={setHighlightedIndex}\n\t\t\t\t\t\t\t\t/>,\n\t\t\t\t\t\t\t\tanchorElementRef.current,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: null\n\t\t\t\t}\n\t\t\t/>\n\t\t</>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-block-picker-plugin.tsx"
    },
    {
      "path": "registry/new-york/editor/block-picker-menu.tsx",
      "content": "import { useRef, useEffect } from 'react';\n\nimport { BlockPickerOption } from '@/lib/BlockPickerOption';\nimport { Input } from '@/components/ui/input';\nimport { BlockPickerMenuItem } from './block-picker-menu-item';\n\ntype BlockPickerMenuProps = {\n\toptions: BlockPickerOption[];\n\tselectedIndex: number | null;\n\tonSelectOption: (option: BlockPickerOption, index: number) => void;\n\tonSetHighlightedIndex: (index: number) => void;\n\tqueryString?: string;\n\tonQueryChange?: (query: string) => void;\n};\n\nexport function BlockPickerMenu({\n\toptions,\n\tselectedIndex,\n\tonSelectOption,\n\tonSetHighlightedIndex,\n\tqueryString,\n\tonQueryChange,\n}: BlockPickerMenuProps) {\n\tconst inputRef = useRef<HTMLInputElement>(null);\n\n\tuseEffect(() => {\n\t\tinputRef.current?.focus();\n\t}, []);\n\n\treturn (\n\t\t<div className=\"bg-popover text-popover-foreground animate-in fade-in-0 zoom-in-95 slide-in-from-top-2 z-50 min-w-50 rounded-md border p-1 shadow-md\">\n\t\t\t{onQueryChange != null && (\n\t\t\t\t<div className=\"p-1 pb-0 mb-1\">\n\t\t\t\t\t<Input\n\t\t\t\t\t\tref={inputRef}\n\t\t\t\t\t\tplaceholder=\"Filter blocks...\"\n\t\t\t\t\t\tvalue={queryString ?? ''}\n\t\t\t\t\t\tonChange={(e) => onQueryChange(e.target.value)}\n\t\t\t\t\t\tclassName=\"h-7 text-xs\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t<div className=\"max-h-50 overflow-y-auto\">\n\t\t\t\t{options.length > 0 ? (\n\t\t\t\t\t<ul className=\"list-none m-0 p-0 mt-1\">\n\t\t\t\t\t\t{options.map((option, i: number) => (\n\t\t\t\t\t\t\t<BlockPickerMenuItem\n\t\t\t\t\t\t\t\tkey={option.key}\n\t\t\t\t\t\t\t\tindex={i}\n\t\t\t\t\t\t\t\tisSelected={selectedIndex === i}\n\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\tonSetHighlightedIndex(i);\n\t\t\t\t\t\t\t\t\tonSelectOption(option, i);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonMouseEnter={() => {\n\t\t\t\t\t\t\t\t\tonSetHighlightedIndex(i);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tsetRefElement={option.setRefElement}\n\t\t\t\t\t\t\t\ticon={option.icon}\n\t\t\t\t\t\t\t\ttitle={option.title}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</ul>\n\t\t\t\t) : (\n\t\t\t\t\t<p className=\"text-muted-foreground text-xs px-2 py-1.5 mt-1\">\n\t\t\t\t\t\tNo results\n\t\t\t\t\t</p>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/block-picker-menu.tsx"
    },
    {
      "path": "registry/new-york/editor/block-picker-menu-item.tsx",
      "content": "import { cn } from '@/lib/utils';\nimport { ReactNode } from 'react';\n\nexport function BlockPickerMenuItem({\n\tindex,\n\tisSelected,\n\tonClick,\n\tonMouseEnter,\n\tsetRefElement,\n\ticon,\n\ttitle,\n}: {\n\tindex: number;\n\tisSelected: boolean;\n\tonClick: () => void;\n\tonMouseEnter: () => void;\n\tsetRefElement: (element: HTMLElement | null) => void;\n\ticon: ReactNode;\n\ttitle: string;\n}) {\n\treturn (\n\t\t<li\n\t\t\ttabIndex={-1}\n\t\t\tclassName={cn(\n\t\t\t\t'flex items-center gap-2 rounded-md px-2 py-1.5 cursor-pointer text-sm',\n\t\t\t\tisSelected\n\t\t\t\t\t? 'bg-accent text-accent-foreground'\n\t\t\t\t\t: 'hover:bg-accent/50',\n\t\t\t)}\n\t\t\tref={setRefElement}\n\t\t\trole=\"option\"\n\t\t\taria-selected={isSelected}\n\t\t\tid={'typeahead-item-' + index}\n\t\t\tonMouseEnter={onMouseEnter}\n\t\t\tonClick={onClick}\n\t\t>\n\t\t\t<span className=\"flex items-center justify-center size-5\">\n\t\t\t\t{icon}\n\t\t\t</span>\n\t\t\t<span>{title}</span>\n\t\t</li>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/block-picker-menu-item.tsx"
    },
    {
      "path": "registry/new-york/editor/decorators/image-decorator.tsx",
      "content": "'use client';\n\nimport type { LexicalCommand, NodeKey } from 'lexical';\nimport type { JSX } from 'react';\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable';\nimport { useLexicalNodeSelection } from '@lexical/react/useLexicalNodeSelection';\nimport { mergeRegister } from '@lexical/utils';\nimport {\n\t$getNodeByKey,\n\t$getSelection,\n\t$isNodeSelection,\n\t$setSelection,\n\tCLICK_COMMAND,\n\tCOMMAND_PRIORITY_LOW,\n\tcreateCommand,\n\tDRAGSTART_COMMAND,\n\tKEY_ESCAPE_COMMAND,\n\tSELECTION_CHANGE_COMMAND,\n} from 'lexical';\nimport {\n\tSuspense,\n\tuseCallback,\n\tuseEffect,\n\tuseMemo,\n\tuseRef,\n\tuseState,\n} from 'react';\nimport { $isImageNode } from '../nodes/image-node';\n\nexport const RIGHT_CLICK_IMAGE_COMMAND: LexicalCommand<MouseEvent> =\n\tcreateCommand('RIGHT_CLICK_IMAGE_COMMAND');\n\n// --- Image cache for suspense ---\n\ntype ImageStatus =\n\t| { error: true }\n\t| { error: false; width: number; height: number };\n\nconst imageCache = new Map<string, Promise<ImageStatus> | ImageStatus>();\n\nfunction useSuspenseImage(src: string): ImageStatus {\n\tlet cached = imageCache.get(src);\n\tif (cached && 'error' in cached && typeof cached.error === 'boolean') {\n\t\treturn cached;\n\t}\n\tif (!cached) {\n\t\tcached = new Promise<ImageStatus>((resolve) => {\n\t\t\tconst img = new Image();\n\t\t\timg.src = src;\n\t\t\timg.onload = () =>\n\t\t\t\tresolve({\n\t\t\t\t\terror: false,\n\t\t\t\t\theight: img.naturalHeight,\n\t\t\t\t\twidth: img.naturalWidth,\n\t\t\t\t});\n\t\t\timg.onerror = () => resolve({ error: true });\n\t\t}).then((result) => {\n\t\t\timageCache.set(src, result);\n\t\t\treturn result;\n\t\t});\n\t\timageCache.set(src, cached);\n\t\tthrow cached;\n\t}\n\tthrow cached;\n}\n\n// --- Sub-components ---\n\nfunction BrokenImage(): JSX.Element {\n\treturn (\n\t\t// eslint-disable-next-line @next/next/no-img-element\n\t\t<img\n\t\t\tsrc=\"/images/image-broken.svg\"\n\t\t\tstyle={{ height: 200, opacity: 0.2, width: 200 }}\n\t\t\tdraggable=\"false\"\n\t\t\talt=\"Broken image\"\n\t\t/>\n\t);\n}\n\nfunction LazyImage({\n\taltText,\n\tclassName,\n\timageRef,\n\tsrc,\n\twidth,\n\theight,\n\tmaxWidth,\n\tonError,\n}: {\n\taltText: string;\n\tclassName: string | null;\n\theight: 'inherit' | number;\n\timageRef: React.RefObject<HTMLImageElement | null>;\n\tmaxWidth: number;\n\tsrc: string;\n\twidth: 'inherit' | number;\n\tonError: () => void;\n}): JSX.Element {\n\tconst status = useSuspenseImage(src);\n\n\tuseEffect(() => {\n\t\tif (status.error) {\n\t\t\tonError();\n\t\t}\n\t}, [status.error, onError]);\n\n\tif (status.error) {\n\t\treturn <BrokenImage />;\n\t}\n\n\treturn (\n\t\t// eslint-disable-next-line @next/next/no-img-element\n\t\t<img\n\t\t\tclassName={className || undefined}\n\t\t\tsrc={src}\n\t\t\talt={altText}\n\t\t\tref={imageRef}\n\t\t\tstyle={{\n\t\t\t\theight,\n\t\t\t\tmaxWidth,\n\t\t\t\twidth,\n\t\t\t}}\n\t\t\tonError={onError}\n\t\t\tdraggable=\"false\"\n\t\t/>\n\t);\n}\n\n// --- Image Resizer ---\n\nfunction ImageResizer({\n\timageRef,\n\tmaxWidth,\n\tonResizeStart,\n\tonResizeEnd,\n}: {\n\timageRef: React.RefObject<HTMLImageElement | null>;\n\tmaxWidth: number;\n\tonResizeStart: () => void;\n\tonResizeEnd: (\n\t\twidth: 'inherit' | number,\n\t\theight: 'inherit' | number,\n\t) => void;\n}) {\n\tconst controlWrapperRef = useRef<HTMLDivElement>(null);\n\tconst startXRef = useRef(0);\n\tconst startYRef = useRef(0);\n\tconst startWidthRef = useRef(0);\n\tconst startHeightRef = useRef(0);\n\tconst ratioRef = useRef(1);\n\tconst directionRef = useRef<'ne' | 'nw' | 'se' | 'sw'>('se');\n\n\tconst handlePointerDown = (\n\t\tevent: React.PointerEvent,\n\t\tdirection: 'ne' | 'nw' | 'se' | 'sw',\n\t) => {\n\t\tconst image = imageRef.current;\n\t\tif (!image) return;\n\n\t\tevent.preventDefault();\n\t\tdirectionRef.current = direction;\n\t\tstartXRef.current = event.clientX;\n\t\tstartYRef.current = event.clientY;\n\n\t\tconst { width, height } = image.getBoundingClientRect();\n\t\tstartWidthRef.current = width;\n\t\tstartHeightRef.current = height;\n\t\tratioRef.current = width / height;\n\n\t\tonResizeStart();\n\n\t\tconst onPointerMove = (e: PointerEvent) => {\n\t\t\tconst dir = directionRef.current;\n\t\t\tconst diffX = e.clientX - startXRef.current;\n\t\t\tconst diffY = e.clientY - startYRef.current;\n\n\t\t\tlet newWidth = startWidthRef.current;\n\t\t\tlet newHeight = startHeightRef.current;\n\n\t\t\tif (dir.includes('e')) newWidth += diffX;\n\t\t\tif (dir.includes('w')) newWidth -= diffX;\n\t\t\tif (dir.includes('s')) newHeight += diffY;\n\t\t\tif (dir.includes('n')) newHeight -= diffY;\n\n\t\t\t// Maintain aspect ratio for corner handles\n\t\t\tif (dir.length === 2) {\n\t\t\t\tconst widthRatio = newWidth / startWidthRef.current;\n\t\t\t\tconst heightRatio = newHeight / startHeightRef.current;\n\t\t\t\tconst ratio = Math.max(widthRatio, heightRatio);\n\t\t\t\tnewWidth = startWidthRef.current * ratio;\n\t\t\t\tnewHeight = startHeightRef.current * ratio;\n\t\t\t}\n\n\t\t\t// Clamp\n\t\t\tnewWidth = Math.max(100, Math.min(newWidth, maxWidth));\n\t\t\tnewHeight = Math.max(100, newHeight);\n\n\t\t\timage.style.width = `${newWidth}px`;\n\t\t\timage.style.height = `${newHeight}px`;\n\t\t};\n\n\t\tconst onPointerUp = () => {\n\t\t\tdocument.removeEventListener('pointermove', onPointerMove);\n\t\t\tdocument.removeEventListener('pointerup', onPointerUp);\n\n\t\t\tconst finalWidth = imageRef.current?.width || startWidthRef.current;\n\t\t\tconst finalHeight =\n\t\t\t\timageRef.current?.height || startHeightRef.current;\n\t\t\tonResizeEnd(finalWidth, finalHeight);\n\t\t};\n\n\t\tdocument.addEventListener('pointermove', onPointerMove);\n\t\tdocument.addEventListener('pointerup', onPointerUp);\n\t};\n\n\tconst handleStyle =\n\t\t'absolute bg-primary border border-background rounded-sm w-2 h-2 z-10';\n\n\treturn (\n\t\t<div ref={controlWrapperRef} className=\"absolute inset-0\">\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -top-1 -left-1 cursor-nw-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'nw')}\n\t\t\t/>\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -top-1 -right-1 cursor-ne-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'ne')}\n\t\t\t/>\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -bottom-1 -left-1 cursor-sw-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'sw')}\n\t\t\t/>\n\t\t\t<div\n\t\t\t\tclassName={`${handleStyle} -bottom-1 -right-1 cursor-se-resize`}\n\t\t\t\tonPointerDown={(e) => handlePointerDown(e, 'se')}\n\t\t\t/>\n\t\t</div>\n\t);\n}\n\n// --- Main Component ---\n\nexport default function ImageDecorator({\n\tsrc,\n\taltText,\n\tnodeKey,\n\twidth,\n\theight,\n\tmaxWidth,\n\tresizable,\n}: {\n\taltText: string;\n\theight: 'inherit' | number;\n\tmaxWidth: number;\n\tnodeKey: NodeKey;\n\tresizable: boolean;\n\tsrc: string;\n\twidth: 'inherit' | number;\n}): JSX.Element {\n\tconst imageRef = useRef<HTMLImageElement | null>(null);\n\tconst [isSelected, setSelected, clearSelection] =\n\t\tuseLexicalNodeSelection(nodeKey);\n\tconst [isResizing, setIsResizing] = useState(false);\n\tconst [editor] = useLexicalComposerContext();\n\tconst activeEditorRef = useRef<\n\t\tReturnType<typeof useLexicalComposerContext>[0] | null\n\t>(null);\n\tconst [isLoadError, setIsLoadError] = useState(false);\n\tconst isEditable = useLexicalEditable();\n\n\tconst isInNodeSelection = useMemo(\n\t\t() =>\n\t\t\tisSelected &&\n\t\t\teditor.getEditorState().read(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\treturn $isNodeSelection(selection) && selection.has(nodeKey);\n\t\t\t}),\n\t\t[editor, isSelected, nodeKey],\n\t);\n\n\tconst $onEscape = useCallback(() => {\n\t\tif (isSelected && isInNodeSelection) {\n\t\t\t$setSelection(null);\n\t\t\teditor.update(() => {\n\t\t\t\tsetSelected(false);\n\t\t\t\tconst parentRootElement = editor.getRootElement();\n\t\t\t\tif (parentRootElement !== null) {\n\t\t\t\t\tparentRootElement.focus();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}, [editor, isSelected, isInNodeSelection, setSelected]);\n\n\tconst onClick = useCallback(\n\t\t(payload: MouseEvent) => {\n\t\t\tif (isResizing) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (payload.target === imageRef.current) {\n\t\t\t\tif (payload.shiftKey) {\n\t\t\t\t\tsetSelected(!isSelected);\n\t\t\t\t} else {\n\t\t\t\t\tclearSelection();\n\t\t\t\t\tsetSelected(true);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t[isResizing, isSelected, setSelected, clearSelection],\n\t);\n\n\tconst onRightClick = useCallback(\n\t\t(event: MouseEvent): void => {\n\t\t\teditor.getEditorState().read(() => {\n\t\t\t\tconst latestSelection = $getSelection();\n\t\t\t\tconst domElement = event.target as HTMLElement;\n\t\t\t\tif (\n\t\t\t\t\tdomElement.tagName === 'IMG' &&\n\t\t\t\t\t$isNodeSelection(latestSelection) &&\n\t\t\t\t\tlatestSelection.getNodes().length === 1\n\t\t\t\t) {\n\t\t\t\t\teditor.dispatchCommand(RIGHT_CLICK_IMAGE_COMMAND, event);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t[editor],\n\t);\n\n\tuseEffect(() => {\n\t\treturn mergeRegister(\n\t\t\teditor.registerCommand(\n\t\t\t\tSELECTION_CHANGE_COMMAND,\n\t\t\t\t(_, activeEditor) => {\n\t\t\t\t\tactiveEditorRef.current = activeEditor;\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerCommand(\n\t\t\t\tDRAGSTART_COMMAND,\n\t\t\t\t(event) => {\n\t\t\t\t\tif (event.target === imageRef.current) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t);\n\t}, [editor]);\n\n\tuseEffect(() => {\n\t\tlet rootCleanup = () => {};\n\t\treturn mergeRegister(\n\t\t\teditor.registerCommand<MouseEvent>(\n\t\t\t\tCLICK_COMMAND,\n\t\t\t\tonClick,\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerCommand<MouseEvent>(\n\t\t\t\tRIGHT_CLICK_IMAGE_COMMAND,\n\t\t\t\tonClick,\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerCommand(\n\t\t\t\tKEY_ESCAPE_COMMAND,\n\t\t\t\t$onEscape,\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerRootListener((rootElement) => {\n\t\t\t\trootCleanup();\n\t\t\t\trootCleanup = () => {};\n\t\t\t\tif (rootElement) {\n\t\t\t\t\trootElement.addEventListener('contextmenu', onRightClick);\n\t\t\t\t\trootCleanup = () =>\n\t\t\t\t\t\trootElement.removeEventListener(\n\t\t\t\t\t\t\t'contextmenu',\n\t\t\t\t\t\t\tonRightClick,\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t() => rootCleanup(),\n\t\t);\n\t}, [editor, $onEscape, onClick, onRightClick]);\n\n\tconst onResizeEnd = (\n\t\tnextWidth: 'inherit' | number,\n\t\tnextHeight: 'inherit' | number,\n\t) => {\n\t\tsetTimeout(() => {\n\t\t\tsetIsResizing(false);\n\t\t}, 200);\n\n\t\teditor.update(() => {\n\t\t\tconst node = $getNodeByKey(nodeKey);\n\t\t\tif ($isImageNode(node)) {\n\t\t\t\tnode.setWidthAndHeight(nextWidth, nextHeight);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst onResizeStart = () => {\n\t\tsetIsResizing(true);\n\t};\n\n\tconst draggable = isInNodeSelection && !isResizing;\n\tconst isFocused = (isSelected || isResizing) && isEditable;\n\n\treturn (\n\t\t<Suspense fallback={null}>\n\t\t\t<div draggable={draggable} className=\"relative inline-block\">\n\t\t\t\t{isLoadError ? (\n\t\t\t\t\t<BrokenImage />\n\t\t\t\t) : (\n\t\t\t\t\t<LazyImage\n\t\t\t\t\t\tclassName={\n\t\t\t\t\t\t\tisFocused\n\t\t\t\t\t\t\t\t? `focused ${isInNodeSelection ? 'draggable' : ''}`\n\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrc={src}\n\t\t\t\t\t\taltText={altText}\n\t\t\t\t\t\timageRef={imageRef}\n\t\t\t\t\t\twidth={width}\n\t\t\t\t\t\theight={height}\n\t\t\t\t\t\tmaxWidth={maxWidth}\n\t\t\t\t\t\tonError={() => setIsLoadError(true)}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{resizable && isInNodeSelection && isFocused && (\n\t\t\t\t\t<ImageResizer\n\t\t\t\t\t\timageRef={imageRef}\n\t\t\t\t\t\tmaxWidth={maxWidth}\n\t\t\t\t\t\tonResizeStart={onResizeStart}\n\t\t\t\t\t\tonResizeEnd={onResizeEnd}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</Suspense>\n\t);\n}\n",
      "type": "registry:component",
      "target": "components/editor/decorators/image-decorator.tsx"
    },
    {
      "path": "registry/new-york/editor/nodes/image-node.tsx",
      "content": "import {\n\t$applyNodeReplacement,\n\tDecoratorNode,\n\tDOMExportOutput,\n\tEditorConfig,\n\tLexicalNode,\n\tNodeKey,\n\tSerializedLexicalNode,\n\tSpread,\n} from 'lexical';\nimport { JSX, lazy, Suspense } from 'react';\n\nconst ImageDecorator = lazy(() => import('../decorators/image-decorator'));\n\nexport interface ImagePayload {\n\taltText: string;\n\theight?: number;\n\tkey?: NodeKey;\n\tmaxWidth?: number;\n\tsrc: string;\n\twidth?: number;\n}\n\nexport type SerializedImageNode = Spread<\n\t{\n\t\tsrc: string;\n\t\taltText: string;\n\t\tmaxWidth: number;\n\t\twidth?: number;\n\t\theight?: number;\n\t},\n\tSerializedLexicalNode\n>;\n\nexport class ImageNode extends DecoratorNode<JSX.Element> {\n\t__src: string;\n\t__altText: string;\n\t__maxWidth: number;\n\t__width: 'inherit' | number;\n\t__height: 'inherit' | number;\n\n\tconstructor(\n\t\tsrc: string,\n\t\taltText: string,\n\t\tmaxWidth: number,\n\t\twidth?: 'inherit' | number,\n\t\theight?: 'inherit' | number,\n\t\tkey?: NodeKey,\n\t) {\n\t\tsuper(key);\n\n\t\tthis.__src = src;\n\t\tthis.__altText = altText;\n\t\tthis.__maxWidth = maxWidth;\n\t\tthis.__width = width || 'inherit';\n\t\tthis.__height = height || 'inherit';\n\t}\n\n\tgetSrc(): string {\n\t\treturn this.__src;\n\t}\n\n\tgetAltText(): string {\n\t\treturn this.__altText;\n\t}\n\n\tsetWidthAndHeight(\n\t\twidth: 'inherit' | number,\n\t\theight: 'inherit' | number,\n\t): void {\n\t\tconst writable = this.getWritable();\n\t\twritable.__width = width;\n\t\twritable.__height = height;\n\t}\n\n\tstatic getType(): string {\n\t\treturn 'image';\n\t}\n\n\tstatic clone(node: ImageNode): ImageNode {\n\t\treturn new ImageNode(\n\t\t\tnode.__src,\n\t\t\tnode.__altText,\n\t\t\tnode.__maxWidth,\n\t\t\tnode.__width,\n\t\t\tnode.__height,\n\t\t\tnode.__key,\n\t\t);\n\t}\n\n\tstatic importJSON(serializedNode: SerializedImageNode): ImageNode {\n\t\treturn new ImageNode(\n\t\t\tserializedNode.src,\n\t\t\tserializedNode.altText,\n\t\t\tserializedNode.maxWidth,\n\t\t\tserializedNode.width,\n\t\t\tserializedNode.height,\n\t\t);\n\t}\n\texportJSON(): SerializedImageNode {\n\t\treturn {\n\t\t\t...super.exportJSON(),\n\t\t\taltText: this.getAltText(),\n\t\t\tmaxWidth: this.__maxWidth,\n\t\t\theight: this.__height === 'inherit' ? 0 : this.__height,\n\t\t\tsrc: this.getSrc(),\n\t\t\twidth: this.__width === 'inherit' ? 0 : this.__width,\n\t\t};\n\t}\n\n\tcreateDOM(config: EditorConfig): HTMLElement {\n\t\tconst span = document.createElement('span');\n\t\tconst theme = config.theme;\n\t\tconst className = theme.image;\n\t\tif (className !== undefined) {\n\t\t\tspan.className = className;\n\t\t}\n\t\treturn span;\n\t}\n\n\tupdateDOM(): false {\n\t\treturn false;\n\t}\n\n\tdecorate(): JSX.Element {\n\t\treturn (\n\t\t\t<Suspense fallback={null}>\n\t\t\t\t<ImageDecorator\n\t\t\t\t\tsrc={this.__src}\n\t\t\t\t\taltText={this.__altText}\n\t\t\t\t\twidth={this.__width}\n\t\t\t\t\theight={this.__height}\n\t\t\t\t\tmaxWidth={this.__maxWidth}\n\t\t\t\t\tnodeKey={this.getKey()}\n\t\t\t\t\tresizable={true}\n\t\t\t\t/>\n\t\t\t</Suspense>\n\t\t);\n\t}\n\n\texportDOM(): DOMExportOutput {\n\t\tconst imgElement = document.createElement('img');\n\t\timgElement.setAttribute('src', this.__src);\n\t\timgElement.setAttribute('alt', this.__altText);\n\t\timgElement.setAttribute('width', this.__width.toString());\n\t\timgElement.setAttribute('height', this.__height.toString());\n\n\t\treturn { element: imgElement };\n\t}\n}\n\nexport function $createImageNode({\n\taltText,\n\theight,\n\tmaxWidth = 500,\n\tsrc,\n\twidth,\n\tkey,\n}: ImagePayload): ImageNode {\n\treturn $applyNodeReplacement(\n\t\tnew ImageNode(src, altText, maxWidth, width, height, key),\n\t);\n}\n\nexport function $isImageNode(\n\tnode: LexicalNode | null | undefined,\n): node is ImageNode {\n\treturn node instanceof ImageNode;\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/image-node.tsx"
    },
    {
      "path": "registry/new-york/editor/image-plugin.tsx",
      "content": "'use client';\n\nimport type { JSX } from 'react';\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { $wrapNodeInElement, mergeRegister } from '@lexical/utils';\nimport {\n\t$createParagraphNode,\n\t$createRangeSelection,\n\t$getSelection,\n\t$insertNodes,\n\t$isNodeSelection,\n\t$isRootOrShadowRoot,\n\t$setSelection,\n\tCOMMAND_PRIORITY_EDITOR,\n\tCOMMAND_PRIORITY_HIGH,\n\tCOMMAND_PRIORITY_LOW,\n\tcreateCommand,\n\tDRAGOVER_COMMAND,\n\tDRAGSTART_COMMAND,\n\tDROP_COMMAND,\n\tisHTMLElement,\n\tLexicalCommand,\n\tLexicalEditor,\n} from 'lexical';\nimport { useEffect } from 'react';\n\nimport {\n\t$createImageNode,\n\t$isImageNode,\n\tImageNode,\n\tImagePayload,\n} from './nodes/image-node';\n\nexport type InsertImagePayload = Readonly<ImagePayload>;\n\nexport const INSERT_IMAGE_COMMAND: LexicalCommand<InsertImagePayload> =\n\tcreateCommand('INSERT_IMAGE_COMMAND');\n\nconst TRANSPARENT_IMAGE =\n\t'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\nlet dragImage: HTMLImageElement | null = null;\nfunction getDragImage(): HTMLImageElement {\n\tif (!dragImage) {\n\t\tdragImage = document.createElement('img');\n\t\tdragImage.src = TRANSPARENT_IMAGE;\n\t}\n\treturn dragImage;\n}\n\nexport default function ImagePlugin(): JSX.Element | null {\n\tconst [editor] = useLexicalComposerContext();\n\n\tuseEffect(() => {\n\t\tif (!editor.hasNodes([ImageNode])) {\n\t\t\tthrow new Error('ImagePlugin: ImageNode not registered on editor');\n\t\t}\n\n\t\treturn mergeRegister(\n\t\t\teditor.registerCommand<InsertImagePayload>(\n\t\t\t\tINSERT_IMAGE_COMMAND,\n\t\t\t\t(payload) => {\n\t\t\t\t\tconst imageNode = $createImageNode(payload);\n\t\t\t\t\t$insertNodes([imageNode]);\n\t\t\t\t\tif ($isRootOrShadowRoot(imageNode.getParentOrThrow())) {\n\t\t\t\t\t\t$wrapNodeInElement(\n\t\t\t\t\t\t\timageNode,\n\t\t\t\t\t\t\t$createParagraphNode,\n\t\t\t\t\t\t).selectEnd();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tCOMMAND_PRIORITY_EDITOR,\n\t\t\t),\n\t\t\teditor.registerCommand<DragEvent>(\n\t\t\t\tDRAGSTART_COMMAND,\n\t\t\t\t(event) => $onDragStart(event),\n\t\t\t\tCOMMAND_PRIORITY_HIGH,\n\t\t\t),\n\t\t\teditor.registerCommand<DragEvent>(\n\t\t\t\tDRAGOVER_COMMAND,\n\t\t\t\t(event) => $onDragover(event),\n\t\t\t\tCOMMAND_PRIORITY_LOW,\n\t\t\t),\n\t\t\teditor.registerCommand<DragEvent>(\n\t\t\t\tDROP_COMMAND,\n\t\t\t\t(event) => $onDrop(event, editor),\n\t\t\t\tCOMMAND_PRIORITY_HIGH,\n\t\t\t),\n\t\t);\n\t}, [editor]);\n\n\treturn null;\n}\n\nfunction $onDragStart(event: DragEvent): boolean {\n\tconst node = $getImageNodeInSelection();\n\tif (!node) {\n\t\treturn false;\n\t}\n\tconst dataTransfer = event.dataTransfer;\n\tif (!dataTransfer) {\n\t\treturn false;\n\t}\n\tdataTransfer.setData('text/plain', '_');\n\tdataTransfer.setDragImage(getDragImage(), 0, 0);\n\tdataTransfer.setData(\n\t\t'application/x-lexical-drag',\n\t\tJSON.stringify({\n\t\t\tdata: {\n\t\t\t\taltText: node.__altText,\n\t\t\t\theight: node.__height,\n\t\t\t\tkey: node.getKey(),\n\t\t\t\tmaxWidth: node.__maxWidth,\n\t\t\t\tsrc: node.__src,\n\t\t\t\twidth: node.__width,\n\t\t\t},\n\t\t\ttype: 'image',\n\t\t}),\n\t);\n\treturn true;\n}\n\nfunction $onDragover(event: DragEvent): boolean {\n\tconst node = $getImageNodeInSelection();\n\tif (!node) {\n\t\treturn false;\n\t}\n\tif (!canDropImage(event)) {\n\t\tevent.preventDefault();\n\t}\n\treturn false;\n}\n\nfunction $onDrop(event: DragEvent, editor: LexicalEditor): boolean {\n\tconst node = $getImageNodeInSelection();\n\tif (!node) {\n\t\treturn false;\n\t}\n\tconst data = getDragImageData(event);\n\tif (!data) {\n\t\treturn false;\n\t}\n\tevent.preventDefault();\n\tif (canDropImage(event)) {\n\t\tconst range = getDragSelection(event);\n\t\tnode.remove();\n\t\tconst rangeSelection = $createRangeSelection();\n\t\tif (range !== null && range !== undefined) {\n\t\t\trangeSelection.applyDOMRange(range);\n\t\t}\n\t\t$setSelection(rangeSelection);\n\t\teditor.dispatchCommand(INSERT_IMAGE_COMMAND, data);\n\t}\n\treturn true;\n}\n\nfunction $getImageNodeInSelection(): ImageNode | null {\n\tconst selection = $getSelection();\n\tif (!$isNodeSelection(selection)) {\n\t\treturn null;\n\t}\n\tconst nodes = selection.getNodes();\n\tconst node = nodes[0];\n\treturn $isImageNode(node) ? node : null;\n}\n\nfunction getDragImageData(event: DragEvent): InsertImagePayload | null {\n\tconst dragData = event.dataTransfer?.getData('application/x-lexical-drag');\n\tif (!dragData) {\n\t\treturn null;\n\t}\n\tconst { type, data } = JSON.parse(dragData);\n\tif (type !== 'image') {\n\t\treturn null;\n\t}\n\treturn data;\n}\n\ndeclare global {\n\tinterface DragEvent {\n\t\trangeOffset?: number;\n\t\trangeParent?: Node;\n\t}\n}\n\nfunction canDropImage(event: DragEvent): boolean {\n\tconst target = event.target;\n\treturn !!(\n\t\tisHTMLElement(target) &&\n\t\t!target.closest('code, span.editor-image') &&\n\t\tisHTMLElement(target.parentElement) &&\n\t\ttarget.parentElement.closest('div.ContentEditable__root')\n\t);\n}\n\nfunction getDragSelection(event: DragEvent): Range | null | undefined {\n\tlet range;\n\tconst target = event.target;\n\tconst targetDocument =\n\t\ttarget instanceof Node ? (target.ownerDocument ?? document) : document;\n\tif (typeof targetDocument.caretPositionFromPoint === 'function') {\n\t\tconst pos = targetDocument.caretPositionFromPoint(\n\t\t\tevent.clientX,\n\t\t\tevent.clientY,\n\t\t);\n\t\tif (pos) {\n\t\t\trange = targetDocument.createRange();\n\t\t\trange.setStart(pos.offsetNode, pos.offset);\n\t\t\trange.collapse(true);\n\t\t}\n\t} else if (event.rangeParent) {\n\t\tconst domSelection = targetDocument.getSelection();\n\t\tif (domSelection !== null) {\n\t\t\tdomSelection.collapse(event.rangeParent, event.rangeOffset || 0);\n\t\t\trange = domSelection.getRangeAt(0);\n\t\t}\n\t} else {\n\t\tthrow Error('Cannot get the selection when dragging');\n\t}\n\treturn range;\n}\n",
      "type": "registry:component",
      "target": "components/editor/image-plugin.tsx"
    },
    {
      "path": "hooks/use-create-editor.ts",
      "content": "'use client';\n\nimport {\n\tAnyLexicalExtension,\n\tEditorThemeClasses,\n\tInitialEditorStateType,\n\tKlass,\n\tLexicalNode,\n} from 'lexical';\nimport { useState } from 'react';\nimport { Editor } from '@/lib/Editor';\n\nexport interface UseCreateEditorOptions {\n\tname?: string;\n\ttheme?: EditorThemeClasses;\n\tnodes?: Array<Klass<LexicalNode>>;\n\textensions?: AnyLexicalExtension[];\n\tinitialEditorState?: InitialEditorStateType;\n}\n\nexport const useCreateEditor = (options: UseCreateEditorOptions = {}) => {\n\tconst [editor] = useState(() => new Editor(options));\n\n\treturn editor;\n};\n",
      "type": "registry:hook",
      "target": "hooks/use-create-editor.ts"
    },
    {
      "path": "lib/Editor.tsx",
      "content": "import {\n\tAnyLexicalExtension,\n\tconfigExtension,\n\tdefineExtension,\n\tEditorThemeClasses,\n\tInitialEditorStateType,\n\tKlass,\n\tLexicalNode,\n} from 'lexical';\nimport { HistoryExtension } from '@lexical/history';\nimport { baseNodes } from './base-nodes';\nimport {\n\tHorizontalRuleExtension,\n\tTabIndentationExtension,\n} from '@lexical/extension';\nimport { CheckListExtension, ListExtension } from '@lexical/list';\nimport { editorTheme } from './default-theme';\nimport { ReactExtension } from '@lexical/react/ReactExtension';\nimport type { BlockPickerOption } from './BlockPickerOption';\nimport { baseBlockPickerOptions } from './base-block-picker-options';\nimport { ImageNode } from '@/components/editor/nodes/image-node';\nimport ImagePlugin from '@/components/editor/image-plugin';\nimport BlockPickerPlugin from '@/components/editor/editor-block-picker-plugin';\n\nexport interface EditorOptions {\n\tname?: string;\n\ttheme?: EditorThemeClasses;\n\tnodes?: Array<Klass<LexicalNode>>;\n\textensions?: AnyLexicalExtension[];\n\tblockPickerOptions?: BlockPickerOption[];\n\tinitialEditorState?: InitialEditorStateType;\n}\n\nexport class Editor {\n\tprivate _lexicalExtension: AnyLexicalExtension;\n\tprivate _blockPickerOptions: BlockPickerOption[];\n\n\tconstructor(options: EditorOptions) {\n\t\tconst {\n\t\t\tname = 'editor',\n\t\t\tnodes = [],\n\t\t\textensions = [],\n\t\t\ttheme = {},\n\t\t\tblockPickerOptions = [],\n\t\t\tinitialEditorState,\n\t\t} = options;\n\t\tthis._blockPickerOptions = [\n\t\t\t...baseBlockPickerOptions,\n\t\t\t...blockPickerOptions,\n\t\t];\n\t\tthis._lexicalExtension = defineExtension({\n\t\t\tname,\n\t\t\t$initialEditorState: initialEditorState,\n\t\t\tnodes: [...baseNodes, ImageNode, ...nodes],\n\t\t\tdependencies: [\n\t\t\t\tHorizontalRuleExtension,\n\t\t\t\tListExtension,\n\t\t\t\tCheckListExtension,\n\t\t\t\tTabIndentationExtension,\n\t\t\t\tHistoryExtension,\n\t\t\t\tconfigExtension(ReactExtension, {\n\t\t\t\t\tcontentEditable: null,\n\t\t\t\t\tdecorators: [\n\t\t\t\t\t\t<BlockPickerPlugin\n\t\t\t\t\t\t\tkey=\"block-picker\"\n\t\t\t\t\t\t\toptions={[\n\t\t\t\t\t\t\t\t...baseBlockPickerOptions,\n\t\t\t\t\t\t\t\t...blockPickerOptions,\n\t\t\t\t\t\t\t]}\n\t\t\t\t\t\t/>,\n\t\t\t\t\t\t<ImagePlugin key=\"image\" />,\n\t\t\t\t\t],\n\t\t\t\t}),\n\t\t\t\t...extensions,\n\t\t\t],\n\t\t\ttheme: { ...editorTheme, ...theme },\n\t\t});\n\t}\n\n\tget lexicalExtension() {\n\t\treturn this._lexicalExtension;\n\t}\n\n\tget blockPickerOptions() {\n\t\treturn this._blockPickerOptions;\n\t}\n}\n",
      "type": "registry:lib",
      "target": "lib/Editor.tsx"
    },
    {
      "path": "lib/base-nodes.ts",
      "content": "import { HorizontalRuleNode } from '@lexical/extension';\nimport { ListItemNode, ListNode } from '@lexical/list';\nimport { HeadingNode, QuoteNode } from '@lexical/rich-text';\nimport { Klass, LexicalNode } from 'lexical';\n\nexport const baseNodes: Array<Klass<LexicalNode>> = [\n\tHeadingNode,\n\tListNode,\n\tListItemNode,\n\tQuoteNode,\n\tHorizontalRuleNode,\n];\n",
      "type": "registry:lib",
      "target": "lib/base-nodes.ts"
    },
    {
      "path": "lib/default-theme.ts",
      "content": "import { EditorThemeClasses } from 'lexical';\nimport './editor-theme.css';\n\nexport const editorTheme: EditorThemeClasses = {\n\tblockCursor: 'EditorTheme__blockCursor',\n\tembedBlock: {\n\t\tbase: 'select-none',\n\t\tfocus: 'outline outline-2 outline-blue-500',\n\t},\n\thashtag: 'bg-primary/10 text-primary px-1 rounded',\n\theading: {\n\t\th1: 'text-[1.875em] font-bold leading-[1.3] mt-[0.5em] mb-[5px] text-foreground',\n\t\th2: 'text-[1.5em] font-semibold leading-[1.3] mt-[0.5em] mb-px text-foreground',\n\t\th3: 'text-[1.25em] font-semibold leading-[1.3] mt-[0.5em] mb-px text-foreground',\n\t\th4: 'text-base font-semibold leading-[1.3] mt-[0.5em] mb-px text-foreground',\n\t\th5: 'text-sm font-semibold leading-[1.3] mt-[0.5em] mb-px text-foreground',\n\t\th6: 'text-xs font-semibold leading-[1.3] mt-[0.5em] mb-px text-foreground',\n\t},\n\thr: 'EditorTheme__hr',\n\timage: 'editor-image',\n\tindent: '[--lexical-indent-base-value:24px]',\n\tlink: 'text-foreground underline decoration-muted-foreground underline-offset-2 hover:decoration-foreground cursor-pointer',\n\tlist: {\n\t\tchecklist: '',\n\t\tlistitem:\n\t\t\t'm-0 pl-[0.2em] leading-normal text-foreground marker:text-foreground',\n\t\tlistitemChecked: 'EditorTheme__listItemChecked',\n\t\tlistitemUnchecked: 'EditorTheme__listItemUnchecked',\n\t\tnested: {\n\t\t\tlistitem: 'list-none before:hidden after:hidden',\n\t\t},\n\t\tolDepth: [\n\t\t\t'm-0 pl-6 list-outside list-decimal',\n\t\t\t'm-0 pl-6 list-outside list-[lower-alpha]',\n\t\t\t'm-0 pl-6 list-outside list-[lower-roman]',\n\t\t\t'm-0 pl-6 list-outside list-decimal',\n\t\t\t'm-0 pl-6 list-outside list-[lower-alpha]',\n\t\t],\n\t\tul: 'm-0 pl-6 list-outside list-disc',\n\t},\n\tparagraph: 'm-0 relative leading-normal text-foreground',\n\tquote: 'my-1 pl-3.5 border-l-[3px] border-border text-muted-foreground',\n\ttab: 'EditorTheme__tabNode',\n\ttext: {\n\t\tbold: 'font-semibold',\n\t\tcapitalize: 'capitalize',\n\t\tcode: 'bg-muted rounded px-[0.4em] py-[0.2em] font-mono text-[85%] text-destructive',\n\t\thighlight: 'bg-accent px-0.5 -mx-0.5',\n\t\titalic: 'italic',\n\t\tlowercase: 'lowercase',\n\t\tstrikethrough: 'line-through',\n\t\tsubscript: 'text-[0.8em] align-sub',\n\t\tsuperscript: 'text-[0.8em] align-super',\n\t\tunderline: 'underline',\n\t\tunderlineStrikethrough: 'underline line-through',\n\t\tuppercase: 'uppercase',\n\t},\n};\n",
      "type": "registry:lib",
      "target": "lib/default-theme.ts"
    },
    {
      "path": "lib/editor-theme.css",
      "content": ".EditorTheme__blockCursor {\n    display: block;\n    pointer-events: none;\n    position: absolute;\n}\n\n.EditorTheme__blockCursor:after {\n    content: '';\n    display: block;\n    position: absolute;\n    top: -2px;\n    width: 20px;\n    border-top: 1px solid var(--foreground);\n    animation: CursorBlink 1.1s steps(2, start) infinite;\n}\n\n@keyframes CursorBlink {\n    to {\n        visibility: hidden;\n    }\n}\n\n.EditorTheme__hr {\n    padding: 0;\n    border: none;\n    margin: 6px 0;\n    cursor: pointer;\n    height: 1px;\n}\n\n.EditorTheme__hr:after {\n    content: '';\n    display: block;\n    height: 1px;\n    background-color: var(--border);\n}\n\n.EditorTheme__hr.EditorTheme__hrSelected {\n    outline: none;\n    background-color: var(--ring);\n}\n\n.EditorTheme__hr.EditorTheme__hrSelected:after {\n    background-color: var(--primary);\n}\n\n.EditorTheme__listItemChecked,\n.EditorTheme__listItemUnchecked {\n    position: relative;\n    margin-left: 0;\n    padding-left: 24px;\n    list-style-type: none;\n    outline: none;\n    display: block;\n    min-height: 1.5em;\n    line-height: 1.5;\n}\n\n.EditorTheme__listItemChecked>*,\n.EditorTheme__listItemUnchecked>* {\n    margin-left: 0;\n}\n\n.EditorTheme__listItemUnchecked:before,\n.EditorTheme__listItemChecked:before {\n    content: '';\n    width: 16px;\n    height: 16px;\n    top: 50%;\n    left: 0;\n    cursor: pointer;\n    display: block;\n    position: absolute;\n    transform: translateY(-50%);\n    border-radius: 3px;\n}\n\n.EditorTheme__listItemChecked {\n    color: var(--muted-foreground);\n    text-decoration: line-through;\n}\n\n.EditorTheme__listItemUnchecked:focus:before,\n.EditorTheme__listItemChecked:focus:before {\n    box-shadow: 0 0 0 2px var(--ring);\n}\n\n.EditorTheme__listItemUnchecked:before {\n    border: 1.5px solid var(--muted-foreground);\n    background: transparent;\n}\n\n.EditorTheme__listItemUnchecked:hover:before {\n    background: var(--accent);\n}\n\n.EditorTheme__listItemChecked:before {\n    border: none;\n    background-color: var(--primary);\n}\n\n.EditorTheme__listItemChecked:after {\n    content: '';\n    cursor: pointer;\n    border-color: var(--primary-foreground);\n    border-style: solid;\n    position: absolute;\n    display: block;\n    top: 50%;\n    width: 3.5px;\n    left: 6px;\n    height: 7px;\n    transform: translateY(-55%) rotate(45deg);\n    border-width: 0 2px 2px 0;\n}\n\n.EditorTheme__tabNode {\n    position: relative;\n    text-decoration: none;\n}\n\n.EditorTheme__tabNode.EditorTheme__textUnderline::after {\n    content: '';\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: 0.15em;\n    border-bottom: 0.1em solid currentColor;\n}\n\n.EditorTheme__tabNode.EditorTheme__textStrikethrough::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0.69em;\n    border-top: 0.1em solid currentColor;\n}\n\n.EditorTheme__tabNode.EditorTheme__textUnderlineStrikethrough::before,\n.EditorTheme__tabNode.EditorTheme__textUnderlineStrikethrough::after {\n    content: '';\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.EditorTheme__tabNode.EditorTheme__textUnderlineStrikethrough::before {\n    top: 0.69em;\n    border-top: 0.1em solid currentColor;\n}\n\n.EditorTheme__tabNode.EditorTheme__textUnderlineStrikethrough::after {\n    bottom: 0.05em;\n    border-bottom: 0.1em solid currentColor;\n}\n",
      "type": "registry:lib",
      "target": "lib/editor-theme.css"
    },
    {
      "path": "lib/base-block-picker-options.tsx",
      "content": "import {\n\tAlignCenter,\n\tAlignLeft,\n\tAlignRight,\n\tHeading1,\n\tHeading2,\n\tHeading3,\n\tImage,\n\tList,\n\tListChecks,\n\tListOrdered,\n\tMinus,\n\tPilcrow,\n\tQuote,\n} from 'lucide-react';\nimport {\n\t$createParagraphNode,\n\t$getSelection,\n\t$isRangeSelection,\n\tFORMAT_ELEMENT_COMMAND,\n} from 'lexical';\nimport { $createHeadingNode, $createQuoteNode } from '@lexical/rich-text';\nimport { $setBlocksType } from '@lexical/selection';\nimport {\n\tINSERT_CHECK_LIST_COMMAND,\n\tINSERT_ORDERED_LIST_COMMAND,\n\tINSERT_UNORDERED_LIST_COMMAND,\n} from '@lexical/list';\nimport { INSERT_HORIZONTAL_RULE_COMMAND } from '@lexical/react/LexicalHorizontalRuleNode';\nimport { BlockPickerOption } from './BlockPickerOption';\nimport { INSERT_IMAGE_COMMAND } from '@/components/editor/image-plugin';\n\nexport const baseBlockPickerOptions: BlockPickerOption[] = [\n\tnew BlockPickerOption({\n\t\tid: 'paragraph',\n\t\ttitle: 'Paragraph',\n\t\ticon: <Pilcrow />,\n\t\tkeywords: ['normal', 'paragraph', 'p', 'text'],\n\t\tcategory: 'basic',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.update(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t$setBlocksType(selection, () => $createParagraphNode());\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'heading-1',\n\t\ttitle: 'Heading 1',\n\t\ticon: <Heading1 />,\n\t\tkeywords: ['heading', 'header', 'h1'],\n\t\tcategory: 'headings',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.update(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t$setBlocksType(selection, () => $createHeadingNode('h1'));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'heading-2',\n\t\ttitle: 'Heading 2',\n\t\ticon: <Heading2 />,\n\t\tkeywords: ['heading', 'header', 'h2'],\n\t\tcategory: 'headings',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.update(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t$setBlocksType(selection, () => $createHeadingNode('h2'));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'heading-3',\n\t\ttitle: 'Heading 3',\n\t\ticon: <Heading3 />,\n\t\tkeywords: ['heading', 'header', 'h3'],\n\t\tcategory: 'headings',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.update(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t$setBlocksType(selection, () => $createHeadingNode('h3'));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'ordered-list',\n\t\ttitle: 'Numbered List',\n\t\ticon: <ListOrdered />,\n\t\tkeywords: ['numbered list', 'ordered list', 'ol'],\n\t\tcategory: 'lists',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined);\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'unordered-list',\n\t\ttitle: 'Bulleted List',\n\t\ticon: <List />,\n\t\tkeywords: ['bulleted list', 'unordered list', 'ul'],\n\t\tcategory: 'lists',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined);\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'check-list',\n\t\ttitle: 'Check List',\n\t\ticon: <ListChecks />,\n\t\tkeywords: ['check list', 'todo list'],\n\t\tcategory: 'lists',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.dispatchCommand(INSERT_CHECK_LIST_COMMAND, undefined);\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'quote',\n\t\ttitle: 'Quote',\n\t\ticon: <Quote />,\n\t\tkeywords: ['block quote', 'quote'],\n\t\tcategory: 'quotes',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.update(() => {\n\t\t\t\tconst selection = $getSelection();\n\t\t\t\tif ($isRangeSelection(selection)) {\n\t\t\t\t\t$setBlocksType(selection, () => $createQuoteNode());\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'divider',\n\t\ttitle: 'Divider',\n\t\ticon: <Minus />,\n\t\tkeywords: ['horizontal rule', 'divider', 'hr'],\n\t\tcategory: 'dividers',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND, undefined);\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'align-left',\n\t\ttitle: 'Align left',\n\t\ticon: <AlignLeft />,\n\t\tkeywords: ['align', 'left'],\n\t\tcategory: 'alignment',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'left');\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'align-center',\n\t\ttitle: 'Align center',\n\t\ticon: <AlignCenter />,\n\t\tkeywords: ['align', 'center'],\n\t\tcategory: 'alignment',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'center');\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'align-right',\n\t\ttitle: 'Align right',\n\t\ticon: <AlignRight />,\n\t\tkeywords: ['align', 'right'],\n\t\tcategory: 'alignment',\n\t\tinsert: ({ editor }) => {\n\t\t\teditor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'right');\n\t\t},\n\t}),\n\tnew BlockPickerOption({\n\t\tid: 'image',\n\t\ttitle: 'Image',\n\t\t// eslint-disable-next-line jsx-a11y/alt-text\n\t\ticon: <Image />,\n\t\tkeywords: ['image', 'img', 'picture', 'photo'],\n\t\tcategory: 'advanced',\n\t\tinsert: ({ editor }) => {\n\t\t\tconst src = window.prompt('Enter image URL');\n\t\t\tif (src) {\n\t\t\t\teditor.dispatchCommand(INSERT_IMAGE_COMMAND, {\n\t\t\t\t\tsrc,\n\t\t\t\t\taltText: '',\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t}),\n];\n",
      "type": "registry:lib",
      "target": "lib/base-block-picker-options.tsx"
    },
    {
      "path": "lib/BlockPickerOption.ts",
      "content": "import type { ReactNode } from 'react';\nimport type { LexicalEditor } from 'lexical';\nimport { MenuOption } from '@lexical/react/LexicalTypeaheadMenuPlugin';\n\nexport type BlockCategory =\n\t| 'basic'\n\t| 'headings'\n\t| 'lists'\n\t| 'quotes'\n\t| 'dividers'\n\t| 'alignment'\n\t| 'advanced';\n\nexport class BlockPickerOption extends MenuOption {\n\ttitle: string;\n\ticon?: ReactNode;\n\tkeywords: readonly string[];\n\tkeyboardShortcut?: string;\n\tcategory: BlockCategory;\n\tinsert: (args: { editor: LexicalEditor; queryString: string }) => void;\n\n\tconstructor(opts: {\n\t\tid: string;\n\t\ttitle: string;\n\t\ticon?: ReactNode;\n\t\tkeywords: readonly string[];\n\t\tkeyboardShortcut?: string;\n\t\tcategory: BlockCategory;\n\t\tinsert: (args: { editor: LexicalEditor; queryString: string }) => void;\n\t}) {\n\t\tsuper(opts.id);\n\t\tthis.title = opts.title;\n\t\tthis.icon = opts.icon;\n\t\tthis.keywords = opts.keywords;\n\t\tthis.keyboardShortcut = opts.keyboardShortcut;\n\t\tthis.category = opts.category;\n\t\tthis.insert = opts.insert;\n\t}\n}\n",
      "type": "registry:lib",
      "target": "lib/BlockPickerOption.ts"
    },
    {
      "path": "lib/color-options.ts",
      "content": "export type ColorOption = {\n\tkey: string;\n\tlabel: string;\n\ticonClassName: string;\n\tvalue: string | null;\n};\n\nexport const TEXT_COLORS: ColorOption[] = [\n\t{\n\t\tkey: 'default',\n\t\tlabel: 'Default',\n\t\ticonClassName: 'text-foreground',\n\t\tvalue: null,\n\t},\n\t{\n\t\tkey: 'gray',\n\t\tlabel: 'Gray',\n\t\ticonClassName: 'text-muted-foreground',\n\t\tvalue: '#6b7280',\n\t},\n\t{\n\t\tkey: 'brown',\n\t\tlabel: 'Brown',\n\t\ticonClassName: 'text-amber-800 dark:text-amber-600',\n\t\tvalue: '#92400e',\n\t},\n\t{\n\t\tkey: 'red',\n\t\tlabel: 'Red',\n\t\ticonClassName: 'text-red-500',\n\t\tvalue: '#ef4444',\n\t},\n\t{\n\t\tkey: 'orange',\n\t\tlabel: 'Orange',\n\t\ticonClassName: 'text-orange-500',\n\t\tvalue: '#f97316',\n\t},\n\t{\n\t\tkey: 'yellow',\n\t\tlabel: 'Yellow',\n\t\ticonClassName: 'text-yellow-500',\n\t\tvalue: '#eab308',\n\t},\n\t{\n\t\tkey: 'green',\n\t\tlabel: 'Green',\n\t\ticonClassName: 'text-green-500',\n\t\tvalue: '#22c55e',\n\t},\n\t{\n\t\tkey: 'blue',\n\t\tlabel: 'Blue',\n\t\ticonClassName: 'text-blue-500',\n\t\tvalue: '#3b82f6',\n\t},\n\t{\n\t\tkey: 'purple',\n\t\tlabel: 'Purple',\n\t\ticonClassName: 'text-purple-500',\n\t\tvalue: '#a855f7',\n\t},\n\t{\n\t\tkey: 'pink',\n\t\tlabel: 'Pink',\n\t\ticonClassName: 'text-pink-500',\n\t\tvalue: '#ec4899',\n\t},\n];\n\nexport const BACKGROUND_COLORS: ColorOption[] = [\n\t{\n\t\tkey: 'default',\n\t\tlabel: 'Default',\n\t\ticonClassName: 'rounded-xs bg-foreground/10 text-foreground',\n\t\tvalue: null,\n\t},\n\t{\n\t\tkey: 'gray',\n\t\tlabel: 'Gray',\n\t\ticonClassName: 'rounded-xs bg-muted-foreground/20 text-muted-foreground',\n\t\tvalue: 'rgba(107, 114, 128, 0.35)',\n\t},\n\t{\n\t\tkey: 'brown',\n\t\tlabel: 'Brown',\n\t\ticonClassName:\n\t\t\t'rounded-xs bg-amber-500/20 text-amber-800 dark:text-amber-600',\n\t\tvalue: 'rgba(245, 158, 11, 0.35)',\n\t},\n\t{\n\t\tkey: 'red',\n\t\tlabel: 'Red',\n\t\ticonClassName: 'rounded-xs bg-red-500/20 text-red-500',\n\t\tvalue: 'rgba(239, 68, 68, 0.35)',\n\t},\n\t{\n\t\tkey: 'orange',\n\t\tlabel: 'Orange',\n\t\ticonClassName: 'rounded-xs bg-orange-500/20 text-orange-500',\n\t\tvalue: 'rgba(249, 115, 22, 0.35)',\n\t},\n\t{\n\t\tkey: 'yellow',\n\t\tlabel: 'Yellow',\n\t\ticonClassName: 'rounded-xs bg-yellow-500/20 text-yellow-500',\n\t\tvalue: 'rgba(234, 179, 8, 0.35)',\n\t},\n\t{\n\t\tkey: 'green',\n\t\tlabel: 'Green',\n\t\ticonClassName: 'rounded-xs bg-green-500/20 text-green-500',\n\t\tvalue: 'rgba(34, 197, 94, 0.35)',\n\t},\n\t{\n\t\tkey: 'blue',\n\t\tlabel: 'Blue',\n\t\ticonClassName: 'rounded-xs bg-blue-500/20 text-blue-500',\n\t\tvalue: 'rgba(59, 130, 246, 0.35)',\n\t},\n\t{\n\t\tkey: 'purple',\n\t\tlabel: 'Purple',\n\t\ticonClassName: 'rounded-xs bg-purple-500/20 text-purple-500',\n\t\tvalue: 'rgba(168, 85, 247, 0.35)',\n\t},\n\t{\n\t\tkey: 'pink',\n\t\tlabel: 'Pink',\n\t\ticonClassName: 'rounded-xs bg-pink-500/20 text-pink-500',\n\t\tvalue: 'rgba(236, 72, 153, 0.35)',\n\t},\n];\n",
      "type": "registry:lib",
      "target": "lib/color-options.ts"
    }
  ],
  "type": "registry:block"
}